/*****************************************************************************
FILE:  easytest.cpp
AUTHOR:	Patrick S. Hamilton
REVISED:	5/13/2002 (PSH); 4/10/2003 (GBM)
  ___________________________________________________________________________

easytest.cpp: Use bdac to generate an annotation file.
Copyright (C) 2001 Patrick S. Hamilton
Copyright (C) 1999 George B. Moody

This file is free software; you can redistribute it and/or modify it under
the terms of the GNU Library General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option) any
later version.

This software is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU Library General Public License for more
details.

You should have received a copy of the GNU Library General Public License along
with this library; if not, write to the Free Software Foundation, Inc., 59
Temple Place - Suite 330, Boston, MA 02111-1307, USA.

You may contact the author by e-mail (pat@eplimited.edu) or postal mail
(Patrick Hamilton, E.P. Limited, 35 Medford St., Suite 204 Somerville,
MA 02143 USA).  For updates to this software, please visit our website
(http://www.eplimited.com).
  __________________________________________________________________________

Easytest.exe is a simple program to help test the performance of our
beat detection and classification software. Data is read from the
indicated ECG file, the channel 1 signal is fed to bdac.c, and the
resulting detections are saved in the annotation file <record>.ate.
<record>.ate may then be compared to <record>.atr to using bxb to
analyze the performance of the the beat detector and classifier detector.

Note that data in the MIT/BIH Arrythmia database file has been sampled
at 360 samples-per-second, but the beat detection and classification
software has been written for data sampled at 200 samples-per-second.
Date is converterted from 360 sps to 200 sps with the function NextSample.
Code for resampling was copied from George Moody's xform utility.  The beat
locations are then adjusted back to coincide with the original sample
rate of 360 samples/second so that the annotation files generated by
easytest can be compared to the "atruth" annotation files.

This file must be linked with object files produced from:
	wfdb software library (source available at www.physionet.org)
	analbeat.cpp
	match.cpp
	rythmchk.cpp
	classify.cpp
	bdac.cpp
	qrsfilt.cpp
	qrsdet.cpp
	postclass.cpp
	noisechk.cpp
  __________________________________________________________________________

  Revisions
	4/13/02:
		Added conditional define statements that allow MIT/BIH or AHA
			records to be processed.
		Normalize input to 5 mV/LSB (200 A-to-D units/mV).

	4/10/03:
		Moved definitions of Record[] array, ECG_DB_PATH, and REC_COUNT
			into "input.h"
*******************************************************************************/
#include "string.h"
#include "win.h"

#include <stdio.h>
#include "wfdb.h"
#include "ecgcodes.h"
#include "ecgmap.h"
#include <pthread.h>
#include <algorithm>
#include "stdio.h"
#include "qrsdet.h"		// For sample rate.
#include "config.h"

//#include "boost/thread.hpp"
#include <complex>
using namespace std;
// External function prototypes.
int putann2(FILE *fp, WFDB_Annotation *annot, long &last_time,int shift_offset);
void wfdb_p16(unsigned int x, FILE *fp);

// Local Prototypes.
char *get_file_name(const char *path);
void remove_extension(char* path);

#ifdef __STDC__
#define MAINTYPE int
#else
#define MAINTYPE void
#endif
const double PI = 3.141592;

void DFT( complex<double> * theData,complex<double> * out, int S)//DFT---matlab
{

    for(unsigned i=0; (i < S); i++)
    {
        out[i].real(0.0);//
        //out[i].imag(0.0);
        //out[i] = complex<double>(0.0, 0.0);
        for(unsigned j=0; (j < S); j++)
        {
            out[i] += theData[j] * polar<double>(1.0, - 2 * PI * i * j / S);
        }

    }

    return;
}
void DFT2(double* theData,double * outr,double * outimag, int S,double * coskn,double* sinkn)
{
    int k,n;
    double out = 0;
    int num = -S;
    for(k=0;k<S;k++)                                          //计算DFT变换后的实部
    {
        //outr[k] = 0.0;
        out = 0.0;
        num += S;
        for(n=0;n<S;n++)
            out+=theData[n]*coskn[num+n];//cos(2*PI*k*n/S);
        outr[k] = out;
    }
    num = -S;
    for(k=0;k<S;k++)                                         //计算DFT变换后的虚部
    {
        outimag[k] = 0.0;
        num += S;
        for(n=0;n<S;n++)
            outimag[k]+=-theData[n]*sinkn[num+n];//sin(2*PI*k*n/S);
    }
}
unsigned int nextPowerOf2(unsigned int n) //nextpow2----matlab
{
    unsigned count = 0;

    // First n in the below condition is for the case where n is 0
    if (n && !(n&(n-1)))
        return n;

    while( n != 0)
    {
        n  >>= 1;
        count += 1;
    }

    return 1 << count;
}

void TESTRECORD::Initial()
{
    lasttime = 0;               //use in putann
    Recordnum;
    modelnum = 0;
    for(int i=0;i<MAXTYPES;i++)
    {
        modeltype[i] = 0;
        modeltypenum[i] = 0;
    }
}
//version 1/*
/*void TESTRECORD::WRITE_THE_TMP(int beatType,BDAC bdac,std::vector< std::vector<int> >& m_clusters,std::vector<int>& m_type,
                               long DetectionTime,int* modeltypen,int* modeltypev,int* delnum)
{
//WRITE THE TMP
    int morphTypenew = bdac.match1.morphType;
    if(beatType == 13){//Q
        if(m_clusters.size()<1){
            m_type.push_back(beatType);
            std::vector<int> newvec;
            newvec.push_back(DetectionTime);
            m_clusters.push_back(newvec);
        }
        else {
            m_clusters[0].push_back(DetectionTime);
        }
    }
    else if(bdac.match1.lastBeatWasNew == 1 ) {
        if(m_type.size()<=MAXTYPES) {
            modeltype[m_type.size()-1] = beatType;
            modeltypenum[m_type.size()-1] = m_type.size();
        }
        else{
            modeltype[morphTypenew] = beatType;
            modeltypenum[morphTypenew] = m_type.size();
        }
        m_type.push_back(beatType);
        std::vector<int> newvec;
        newvec.push_back(DetectionTime);
        m_clusters.push_back(newvec);
    }
    else
    {
        if (bdac.match1.CombineInType != -1)
        {//refresh the m_cluster after combine 2 models
            int Intype = modeltypenum[bdac.match1.CombineInType];
            int Deltype = modeltypenum[bdac.match1.CombineDelType];
            for (int k = 0; k < m_clusters[Deltype].size(); k++) {
                m_clusters[Intype].push_back(m_clusters[Deltype].at(k));
            }
            std::sort(m_clusters[Intype].begin(), m_clusters[Intype].end());
            m_clusters.erase(m_clusters.begin() + Deltype);
            m_type.erase(m_type.begin() + Deltype);
            for (int idel = bdac.match1.CombineDelType; idel < bdac.match1.TypeCount; idel++) {
                modeltypenum[idel] = modeltypenum[idel + 1];
            }
            //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%//
            //think here has some wrong
            for (int idel = 0; idel < bdac.match1.TypeCount; idel++) { //MAXTYPES
                if (modeltypenum[idel] == Deltype)
                    modeltypenum[idel] = Intype;
                if (modeltypenum[idel] > Deltype)
                    modeltypenum[idel]--;
            }

            for (int k = 0; k < bdac.match1.TypeCount + 1; k++) {  //MAXTYPES
                if (modeltypen[k] == Deltype) {
                    modeltypen[k] = Intype;
                }
                if (modeltypen[k] > Deltype) {
                    modeltypen[k] = modeltypen[k] - 1;
                }
            }
            for (int k = 0; k < bdac.match1.TypeCount + 1; k++) {  //MAXTYPES
                if (modeltypev[k] == Deltype) {
                    modeltypev[k] = Intype;
                }
                if (modeltypev[k] > Deltype) {
                    modeltypev[k] = modeltypev[k] - 1;
                }

            }
            *delnum++;
            if (morphTypenew == bdac.match1.CombineDelType)
                morphTypenew = bdac.match1.CombineInType;
            if (morphTypenew > bdac.match1.CombineDelType)
                morphTypenew--;
        }

        int numtypeout = modeltypenum[morphTypenew];
        if (m_type[numtypeout] == beatType) {
            m_clusters[numtypeout].push_back(DetectionTime);
        }
        else {
            if (beatType == 1) {
                if (modeltypen[morphTypenew] == 0) {
                    m_type.push_back(beatType);
                    modeltypen[morphTypenew] = m_type.size() - 1;
                    std::vector<int> newvec;
                    newvec.push_back(DetectionTime);
                    m_clusters.push_back(newvec);
                }
                else {

                    numtypeout = modeltypen[morphTypenew];
                    m_clusters[numtypeout].push_back(DetectionTime);
                }
            }
            else {
                if (modeltypev[morphTypenew] == 0) {
                    m_type.push_back(beatType);
                    modeltypev[morphTypenew] = m_type.size() - 1;
                    std::vector<int> newvec;
                    newvec.push_back(DetectionTime);
                    m_clusters.push_back(newvec);
                }
                else {
                    numtypeout = modeltypev[morphTypenew];
                    m_clusters[numtypeout].push_back(DetectionTime);
                }
            }

        }
    }
}*/
//
void TESTRECORD::WRITE_THE_TMP(int beatType,BDAC bdac,std::vector< std::vector<int> >& m_clusters,std::vector<int>& m_type,std::vector<int>& Q_type,
                               long DetectionTime,int* modeltypen,int* modeltypev,int* delnum)
{
//WRITE THE TMP
    int DetectionT = (int)DetectionTime;
    int morphTypenew = bdac.match1.morphType;
    if(beatType == 13){//Q
        Q_type.push_back(DetectionT);
    }
    else if(bdac.match1.lastBeatWasNew == 1 ) {
        std::vector<int> newnormal;
        std::vector<int> newv;
        if(1==beatType)
            newnormal.push_back(DetectionT);
        else
            newv.push_back(DetectionT);
        m_clusters.push_back(newnormal);
        m_clusters.push_back(newv);
        m_type.push_back(1);
        m_type.push_back(5);
        modeltypenum[morphTypenew]=m_type.size()-2;

    }
    else
    {
        int numtypeout = modeltypenum[morphTypenew];
        if(1==beatType)
            m_clusters[numtypeout].push_back(DetectionT);
        else if(5==beatType)
            m_clusters[numtypeout+1].push_back(DetectionT);

        if (bdac.match1.CombineInType != -1) {   //refresh the m_cluster after combine 2 models
            int Intype = modeltypenum[bdac.match1.CombineInType];
            int Deltype = modeltypenum[bdac.match1.CombineDelType];
            if(Intype!=Deltype) {
                for (int k = 0; k < m_clusters[Deltype].size(); k++) {
                    m_clusters[Intype].push_back(m_clusters[Deltype].at(k));
                }
                int vinid = Intype + 1;
                int vdelid = Deltype + 1;
                for (int k = 0; k < m_clusters[vdelid].size(); k++) {
                    m_clusters[vinid].push_back(m_clusters[vdelid].at(k));
                }
                std::sort(m_clusters[Intype].begin(), m_clusters[Intype].end());
                std::sort(m_clusters[Intype + 1].begin(), m_clusters[Intype + 1].end());
                m_clusters.erase(m_clusters.begin() + Deltype + 1);
                m_clusters.erase(m_clusters.begin() + Deltype);
                m_type.erase(m_type.begin() + Deltype + 1);
                m_type.erase(m_type.begin() + Deltype);
                for (int idel = bdac.match1.CombineDelType; idel < bdac.match1.TypeCount; idel++) { //MAXTYPES
                    modeltypenum[idel] = modeltypenum[idel + 1];
                }
                for (int idel = 0; idel < bdac.match1.TypeCount; idel++) { //MAXTYPES
                    if (modeltypenum[idel] > Deltype)
                        modeltypenum[idel] -= 2;
                }
            }
        }
    }
}
//{
////WRITE THE TMP
//    int DetectionT = (int)DetectionTime;
//    int morphTypenew = bdac.match1.morphType;
//    if(beatType == 13){//Q
//        Q_type.push_back(DetectionT);
//    }
//    else if(bdac.match1.lastBeatWasNew == 1 ) {
//        std::vector<int> newnormal;
//        std::vector<int> newv;
//        if(1==beatType)
//            newnormal.push_back(DetectionT);
//        else
//            newv.push_back(DetectionT);
//        m_clusters.push_back(newnormal);
//        m_clusters.push_back(newv);
//        m_type.push_back(1);
//        m_type.push_back(5);
//        modeltypenum[morphTypenew]=m_type.size()-2;
//
//    }
//    else
//    {
//        int numtypeout = modeltypenum[morphTypenew];
//        if(1==beatType)
//            m_clusters[numtypeout].push_back(DetectionT);
//        else if(5==beatType)
//            m_clusters[numtypeout+1].push_back(DetectionT);
//
//        if (bdac.match1.CombineInType != -1) {   //refresh the m_cluster after combine 2 models
//            int Intype = modeltypenum[bdac.match1.CombineInType];
//            int Deltype = modeltypenum[bdac.match1.CombineDelType];
//            for (int k = 0; k < m_clusters[Deltype].size(); k++) {
//                m_clusters[Intype].push_back(m_clusters[Deltype].at(k));
//            }
//            int vinid = Intype + 1;
//            int vdelid = Deltype + 1;
//            for (int k = 0; k < m_clusters[vdelid].size(); k++) {
//                m_clusters[vinid].push_back(m_clusters[vdelid].at(k));
//            }
//            std::sort(m_clusters[Intype].begin(), m_clusters[Intype].end());
//            std::sort(m_clusters[Intype + 1].begin(), m_clusters[Intype + 1].end());
//            m_clusters.erase(m_clusters.begin() + Deltype+1);
//            m_clusters.erase(m_clusters.begin() + Deltype);
//            m_type.erase(m_type.begin() + Deltype + 1);
//            m_type.erase(m_type.begin() + Deltype);
//            for (int idel = bdac.match1.CombineDelType; idel < bdac.match1.TypeCount; idel++) { //MAXTYPES
//                modeltypenum[idel] = modeltypenum[idel+1];
//            }
//            for (int idel = 0; idel < bdac.match1.TypeCount; idel++) { //MAXTYPES
//                if (modeltypenum[idel] > Deltype)
//                    modeltypenum[idel] -= 2;
//            }
//        }
//    }
//}


int TESTRECORD::TestRecord(const char *data_file_path)
	{
    char *data_file_name;
    char date_tmp[_MAX_PATH]; //XXX/201414/
    char ecg_file_name[_MAX_PATH];
    char date_path[_MAX_PATH];
    char ecg_filtered_data_file_path[_MAX_PATH]; //saved file name
    char ecg_annotation_file_path[_MAX_PATH]; //saved file name
    char ecg_head_file_path[_MAX_PATH]; //saved file name           7
    char ecg_tmp_file_path[_MAX_PATH]; //saved file name           7
    char ecg_config_file_path[_MAX_PATH];// the path with config
    //get the read 1-channal-dat and write 2-channal-dat path
    string WRITE_PATH,READ_PATH;
    conf::Instance()->Load(SYS_CONF);
    conf::Instance()->Get("write_path", WRITE_PATH);
    conf::Instance()->Get("read_path", READ_PATH);
    //get the filename and the last foldername
    memset(date_tmp, 0, _MAX_PATH);
    data_file_name = get_file_name(data_file_path);
    strncpy(ecg_file_name, data_file_name,_MAX_PATH);
    remove_extension(ecg_file_name);
    strncpy(date_tmp, data_file_path, strlen(data_file_path) - strlen(data_file_name) - 1);
    strncpy(date_path, get_file_name(date_tmp),_MAX_PATH);
    //get the full file path
    snprintf(ecg_filtered_data_file_path,_MAX_PATH, "%s/%s/%s.dat", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_annotation_file_path,_MAX_PATH, "%s/%s/%s.bsp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_head_file_path,_MAX_PATH, "%s/%s/%s.hea", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_tmp_file_path,_MAX_PATH, "%s/%s/%s.tmp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_config_file_path,_MAX_PATH, "%s/%s/%s.cnf", READ_PATH.c_str(), date_path, ecg_file_name);
    //variable initial
    Initial();
    //use the google_protobuf
    GOOGLE_PROTOBUF_VERIFY_VERSION;
    //Template tmp;
    temp::BeatTemplate *tmpN=tmp.add_beat_templates();
    temp::BeatTemplate *tmpA=tmp.add_beat_templates();
    temp::BeatTemplate *tmpV=tmp.add_beat_templates();
    tmpA->set_type(BeatTemplate::A);
    tmpN->set_type(BeatTemplate::N);
    tmpV->set_type(BeatTemplate::V);
    //using in tmp
    int modeltypev[MAXTYPES+1];
    int modeltypen[MAXTYPES+1];
    for(int i=0;i<MAXTYPES+1;i++)
    {
        modeltypev[i] = 0;
        modeltypen[i] = 0;
    }
    std::vector< std::vector<int> > m_clusters;
    std::vector<int> m_type;
    std::vector<int> Q_type;
    //write to annot
    WFDB_Annotation annot ;
    FILE *fileann = fopen(ecg_annotation_file_path,"wb");//

   //find QRS
	int delay;
    int InputFileSampleFrequency = 128;
    long SampleCount = 0;
    long DetectionTime = 0;
    int beatType, beatMatch ;
    lasttime =0;


    // Open a 1 channel record
    FILE* filed = fopen(data_file_path,"r");//
    if(!filed){
        printf("please check the file:%s!",data_file_path);
        return 0;
    }
    fseek(filed,0,2);
    long flend=ftell(filed); // 得到文件大小
    int lengthd = flend/3;
    int posd=0;              // read the 1-channal-locate, once by 3 chars
    char* lpc = new char[flend]; //read
    int* INlpc = new int[lengthd*2];//the real data in 1-channal-file
    int* OUTlpc = new int[lengthd*2];//the real data in 2-channal-file
    fseek(filed, 0, SEEK_SET);
    fread(lpc, flend,1,filed);
    int dataIN;

    //write to the 2-channal-dat file
    int file2c_lsize = flend*2;
    FILE* fp = fopen(ecg_filtered_data_file_path,"w");
    if (fp == NULL){
        printf("can't open the output 2-channel file!");
        return 0;
     }
    char *buf = new char[file2c_lsize];//(char *) malloc(file2c_lsize);
    char* lpc2 = (char *) buf;

    //write the head file
    FILE *filehea = fopen(ecg_head_file_path, "w");
    int sNum = 2;
    float sr = 128;
    int res = fprintf(filehea, "%s %d %3.0f %d\n", ecg_file_name, sNum, sr, file2c_lsize);
    int eNum = 0;
    int umv = 549, bits = 212, resolution = 12, zero = 0, crc = 0, firstdata = 0;
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s\n", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    fclose(filehea);

    int delnum=0;
    // Initialize beat detection and classification.
    BDAC bdac;
    bdac.ResetBDAC() ;                                                   //bdac.c
    int lpcount = 0;

    /*    double Fs = 128;//采样频率
        double T = 1/Fs;//采样间隔
        int L2=36;
        int nfft = nextPowerOf2(L2);

        double dataL[36];// = {-22,11,30,36,30,24,18,11,4,-1,-1,2,8,15,26,41,54,41,-5,-65,-100,-91,-52,-10,15,26,27,22,15,10,7,6,5,3,2,1};
        double* dataind2 = new double[nfft];
        double* datafftr2 = new double[nfft];
        double* dataffti2 = new double[nfft];
        double* coskn = new double[nfft*nfft];
        double* sinkn = new double[nfft*nfft];
        int num = -nfft;
        for(int i=0;i<nfft;i++) {
            dataind2[i] = 0.0;
            datafftr2[i] = 0.0;
            dataffti2[i] = 0.0;
            num += nfft;
            for(int k=0;k<nfft;k++)
            {
                coskn[num+k] = cos(2*PI*k*i/nfft);
                sinkn[num+k] = sin(2*PI*k*i/nfft);
            }
        }
*/
    // Read data from MIT/BIH file until tre is none left.
    while( posd < lengthd)  //local
    {
        if(SampleCount%2==0) {
            dataIN = MAKEWORD(lpc[posd * 3 ], (lpc[posd * 3 + 1 ] & 0x0f));
        }
        else {
            dataIN = MAKEWORD(lpc[posd * 3 + 2], (lpc[posd * 3 + 1] & 0xf0) >> 4);
            posd++;
        }

        if (dataIN & 0x800)
             dataIN |= ~(0xfff); //negative  data, make all the high bit(12 and after) 1
        else dataIN &= 0xfff;        //positive data, make all the hight bit 0
        ++SampleCount ;
        // Pass sample to beat detection and classification.
        delay = bdac.BeatDetectAndClassify(dataIN, &beatType, &beatMatch) ;    //bdac.c
        //save the real-data
        OUTlpc[lpcount] =bdac.qrsdet1.datafilt;
        INlpc[lpcount++] = dataIN;
       // printf("%d\n",SampleCount);
        // If a beat was detected, annotate the beat location and type.
        if(delay != 0)
        {
            DetectionTime = SampleCount - delay ;

            int maxfiltdn = 0;
            int maxid = 0;
            int id = 0;
            for(int i=5;i<41;i++)
            {
                id = bdac.ECGBufferIndex-delay+i-9;//35+26;
                if(id<0)
                    id += ECG_BUFFER_LENGTH;
                if(id>=ECG_BUFFER_LENGTH)
                    id -= ECG_BUFFER_LENGTH;
                //dataL[i-5] = bdac.ECGBufferfilt[id];
                if(bdac.ECGBufferfilt[id]>maxfiltdn)
                {
                    maxfiltdn = bdac.ECGBufferfilt[id];
                    maxid = i;
                }
            }
            if(maxid >5&& maxid<31)
                DetectionTime +=maxid-18;
         /*   for(int i=0;i<L2;i++){
                dataind2[i] = dataL[i];
            }

            //DFT(dataind,datafft,datafft,nfft);
            DFT2(dataind2,datafftr2,dataffti2,nfft,coskn,sinkn);
            double datafftout= sqrt(pow(datafftr2[5]/36,2) + pow(dataffti2[5]/36,2));

//            for(int i=0;i<L2;i++){
//                datafftout[i] = sqrt(pow(abs(datafft[i].real())/36,2) + pow(abs(datafft[i].imag()/36),2));
//            }
            //printf("%f\n",datafftout);
            //threshold of pinyu and not comerge the tmp and not create the tmp
            //want to add a threshold ,for example the counts of cross zero
            if((datafftout<8||datafftout>100) && bdac.match1.CombineInType==-1&&bdac.match1.lastBeatWasNew != 1 ) {
                beatType = 13;
            }
*/
            // Convert sample count to input file sample rate.
            DetectionTime *= InputFileSampleFrequency ;
            DetectionTime /= SAMPLE_RATE ;
            if(annot.time>=DetectionTime){
                continue;
            }
            annot.time = DetectionTime ;
            annot.anntyp = beatType ;
            annot.aux = NULL ;
            putann2(fileann,&annot,lasttime,0);
            //WRITE TO THE TMP
            WRITE_THE_TMP(beatType, bdac, m_clusters, m_type, Q_type, DetectionTime, modeltypen, modeltypev,&delnum);
        }
    }

 /*   delete[]dataind2;
    delete[]datafftr2;
    delete[]dataffti2;
    delete[]sinkn;
    delete[]coskn;
*/

    //2 int change to 3 chars
    int dif = LPBUFFER_LGTH/2-1+(HPBUFFER_LGTH-1)/2;
    for(int i=0;i<lengthd*2;i++)
    {
        int id = i+dif;
        if(id>=lengthd*2){
            id=lengthd*2-1;
        }
        lpc2[0] = LOBYTE((short) INlpc[i]);
        lpc2[1] = 0;
        lpc2[1] = HIBYTE((short) INlpc[i]) & 0x0f;
        lpc2[2] = LOBYTE((short) OUTlpc[id]);
        lpc2[1] |= HIBYTE((short) OUTlpc[id]) << 4;
        lpc2 += 3;
    }
    fwrite( buf, sizeof(char), file2c_lsize, fp);
    fclose(fp);//close the 2-channal-dat file
    delete[]buf;
    delete[]lpc;
    delete[]INlpc;
    delete[]OUTlpc;
    //
    //printf("Record:%s,%d,%d\n",data_file_name,m_type.size(),delnum);
    wfdb_p16(0, fileann);//STOP WRITE THE ATEST FILE
    fclose(fileann);//CLOSE WRITE THE annotion FILE
    fclose(filed); //CLOSE THE 1-channal-DAT FILE

    // Write the new address book back to disk.
    int Nnum = 0, Vnum=0, Anum = 0;
    int countN = 0,countV = 0,countA=0;
    bool Nfind1 = false, Vfind1 = false, Afind1 = false;
    int Nfind1ID = 0, Vfind1ID = 0, Afind1ID = 0;
    fstream tempfile(ecg_tmp_file_path, ios::out | ios::trunc | ios::binary);
    Template1 *tmp1N = tmpN->add_template1s();
        tmp1N->set_id(0);
    Template1 *tmp1V = tmpV->add_template1s();
        tmp1V->set_id(0);
    Template1 *tmp1A = tmpA->add_template1s();
        tmp1A->set_id(0);

   if (Q_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1A->add_template2s();
        tmp1->set_id(0);
        countA += Q_type.size();
        for (int k = 0; k < Q_type.size(); k++) {
            tmp1->add_positions_of_beats(Q_type[k]);
        }
    }
    for (int j = 0; j < m_type.size(); ++j) {
        int type = m_type[j];
        if(!m_clusters[j].size())
            continue;

        Template2 *tmp1;
        int numID = 0;
        if (1 == type) {
            if (m_clusters[j].size() > MERRGENUM) {
                tmp1 = tmp1N->add_template2s();
                tmp1->set_id(0);
                numID = Nnum++;
                countN += m_clusters[j].size();
                for (int k = 0; k < m_clusters[j].size(); k++) {
                    tmp1->add_positions_of_beats(m_clusters[j][k]);
                }
            }
            else {
                if (!Nfind1) {
                    Nfind1 = true;
                    Nfind1ID = j;
                }
                for (int k = 0; k < MERRGENUM; ++k) {
                    m_clusters[Nfind1ID].push_back(m_clusters[j][k]);
                }
            }
        }
        else if (5 == type)
        {
            if (m_clusters[j].size() > MERRGENUM) {
                tmp1 = tmp1V->add_template2s();
                numID = Vnum++;
                countV += m_clusters[j].size();
                for (int k = 0; k < m_clusters[j].size(); k++) {
                    tmp1->add_positions_of_beats(m_clusters[j][k]);
                }
            }
            else {
                if (!Vfind1) {
                    Vfind1 = true;
                    Vfind1ID = j;
                }
                for (int k = 0; k < MERRGENUM; ++k) {
                    m_clusters[Vfind1ID].push_back(m_clusters[j][k]);
                }

            }
        }
        else {
            if (m_clusters[j].size() > MERRGENUM) {
                tmp1 = tmp1A->add_template2s();
                numID = Anum++;
                countA += m_clusters[j].size();
            }
            else {
                if (!Afind1) {
                    Afind1 = true;
                    Afind1ID = j;
                }

                for (int k = 0; k < MERRGENUM; ++k) {
                    m_clusters[Afind1ID].push_back(m_clusters[j][k]);
                }
            }
        }
    }
    if(Nfind1 == true) {
        int numID = Nnum++;
        countN += m_clusters[Nfind1ID].size();
        Template2 *tmp2 = tmp1N->add_template2s();
        tmp2->set_id(0);
        for(int k=0;k<m_clusters[Nfind1ID].size();k++) {
            tmp2->add_positions_of_beats(m_clusters[Nfind1ID][k]);
        }
    }
    if(Vfind1 == true) {
        int numID = Vnum++;
        countV += m_clusters[Vfind1ID].size();
        Template2 *tmp2 = tmp1V->add_template2s();
        tmp2->set_id(0);//numID);
        for(int k=0;k<m_clusters[Vfind1ID].size();k++) {
            tmp2->add_positions_of_beats(m_clusters[Vfind1ID][k]);
        }
    }
    if(Afind1 == true)
    {
        int numID = Anum++;
        countA += m_clusters[Afind1ID].size();
        Template2 *tmp2 = tmp1A->add_template2s();
        tmp2->set_id(0);//numID);
        for(int k=0;k<m_clusters[Afind1ID].size();k++) {
            tmp2->add_positions_of_beats(m_clusters[Afind1ID][k]);
        }
    }
    printf("all tmp = %d\n", Anum + Vnum +Nnum);
    if (!tmp.SerializeToOstream(&tempfile)) {
        cerr << "Failed to write address book." << endl;
        return -1;
    }
    google::protobuf::ShutdownProtobufLibrary();

    return 0;
}

int TESTRECORD::ReSearchQRS(const char *data_file_path, std::vector<int> locatebegin , std::vector<int> locateend, std::vector<std::vector<int>>*  FindrunS)
{
    FILE* filed = fopen(data_file_path,"r");//
    if(!filed){
        printf("please check the file:%s!",data_file_path);
        return 0;
    }
    fseek(filed,0,2);
    long flend=ftell(filed); // 得到文件大小
    int lengthd = flend/3;
    int posd=0;
    char* lpc = new char[flend];//(char *) malloc(flend);//
    fseek(filed, 0, SEEK_SET);
    fread(lpc, flend,1,filed);
    int dataIN;
    int dataOUT;
    int SampleCount = 0 ;
    int locateID=0;
    QRSdetcls qrsdet;
    // Read data from MIT/BIH file until tre is none left.
    while( posd < lengthd)  //local
    {
        // NextSample2(ecgd,1,InputFileSampleFrequency,SAMPLE_RATE,0 );      //local
        if (SampleCount % 2 == 0) {
            dataIN = MAKEWORD(lpc[posd * 3], (lpc[posd * 3 + 1] & 0x0f));
        }
        else {
            dataIN = MAKEWORD(lpc[posd * 3 + 2], (lpc[posd * 3 + 1] & 0xf0) >> 4);
            posd++;
        }

        if(SampleCount == locatebegin[locateID]){
            vector<int> delays;
            FindrunS->push_back(delays);
            qrsdet.ResetQRSdet();
            qrsdet.det_thresh = 10;
        }
        else if(SampleCount == locateend[locateID]){
            locateID++;
            if(locateID >= locatebegin.size())
            {
                posd = lengthd;
            }
        }
        else if(SampleCount > locatebegin[locateID]&& SampleCount < locateend[locateID])
        {
            if (dataIN & 0x800)
                dataIN |= ~(0xfff); //negative  data, make all the high bit(12 and after) 1
            else dataIN &= 0xfff;        //positive data, make all the hight bit 0

            int delay = qrsdet.QRSDetFront(dataIN);
            if(delay!=0){
                int loca = SampleCount-45;
                FindrunS->at(locateID).push_back(loca);
            }
        }
        ++SampleCount;
    }

    delete[]lpc;
    fclose(filed);
    return 1;
}

int TESTRECORD::ReSearchSpecial(const char *data_file_path, int locatebegin, int locateend, int locatepoint , std::vector<int> *locatespecial)
{
    FILE* filed = fopen(data_file_path,"r");//
    if(!filed){
        printf("please check the file:%s!",data_file_path);
        return 0;
    }

    //////////////////////////////////
    fseek(filed,0,2);
    long flend=ftell(filed); // 得到文件大小
    int lengthd = flend/3;
    int posd=0;
    char* lpc = new char[flend];//(char *) malloc(flend);//
    fseek(filed, 0, SEEK_SET);
    fread(lpc, flend,1,filed);
    int dataIN;
    int dataOUT;
    int SampleCount = 0 ;
    int locateID=0;
    QRSdetcls qrsdet;
    //比较特征
    int specialbuf[SPECQRS_lGTH];
    int specid = 0;
    int qrsbuf[SPECQRS_lGTH];
    int bufID = 0;
    int start =locatepoint-SPECQRS_lGTH/2;
    if(start<0){
        start = 0;
    }
    int specpos = start;
    double sumspec  = 0;
    double mean = 0;
    double specdis[SPECQRS_lGTH];
    double s2 = 0;
    double sumloc  = 0;
    double meanloc = 0;
    double s1 = 0;
    double s = 0;
    int locdn[SPECQRS_lGTH];
    int locdis[SPECQRS_lGTH];
    int k=0;
    for (int i=0;i<SPECQRS_lGTH;i++)
    {
        specialbuf[i]=0;
        qrsbuf[i]=0;
        specdis[i]=0;
        locdn[i]=0;
        locdis[i]=0;
    }
    for(int i=0;i<SPECQRS_lGTH;i++)
    {
        dataIN = MAKEWORD(lpc[specpos * 3 + 2], (lpc[specpos * 3 + 1] & 0xf0) >> 4);
        specpos++;
        if (dataIN & 0x800)
            dataIN |= ~(0xfff); //negative  data, make all the high bit(12 and after) 1
        else dataIN &= 0xfff;        //positive data, make all the hight bit 0
        specialbuf[specid++] = dataIN;
        sumspec += dataIN;
    }
    mean = sumspec/SPECQRS_lGTH;
    for(int i=0;i<SPECQRS_lGTH;i++){
        specdis[i] = specialbuf[i] - mean;
        s2 += specdis[i]*specdis[i];
    }
    double rscore[3];
    rscore[0] = rscore[1] =rscore[2]=0;

    int n=strlen(data_file_path);
    char ecg_annotation_file_path[100];
    for(int i=n;i>=0;i--){
        if(data_file_path[i]=='.'){
            ecg_annotation_file_path[i] = data_file_path[i];
            ecg_annotation_file_path[++i]='b';
            ecg_annotation_file_path[++i]='s';
            ecg_annotation_file_path[++i]='p';
            i-=3;
        }
        else{
            ecg_annotation_file_path[i] = data_file_path[i];
        }
    }
    FILE *file_atr = fopen(ecg_annotation_file_path,"rb");
    if (file_atr==NULL)
    {
//        LOG(ERROR) << "There is no " << ecg_annotation_file_path;
        return 0;
    }

    int prePos=0;
    WFDB_Annotation annot;
    long last_time=0;
    short last_offset=0;
    int curPos;
    int index=0;
    vector<int> locset;
    locset.push_back(locatebegin);
    while (getann(file_atr, &annot, last_time, last_offset)==0) {
        curPos = annot.time;
        if(curPos>locatebegin && curPos<locateend)
        {
            if(curPos-15<=locatebegin){
                locset.push_back(locatebegin+1);
            }
            else
                locset.push_back(curPos-15);
            if(curPos+15>=locateend){
                locset.push_back(locateend-1);
            }
            else
                locset.push_back(curPos+15);
        }
    }
    locset.push_back(locateend);
    int locsetid = 0;
    // Read data from MIT/BIH file until tre is none left.
    while( posd < lengthd)  //local
    {

       dataIN = MAKEWORD(lpc[posd * 3 + 2], (lpc[posd * 3 + 1] & 0xf0) >> 4);
       posd++;

       if(SampleCount == locset[locsetid+1]){
           if((locsetid+1)==locset.size()){
               posd = lengthd;
           }
           else{
               locsetid += 2;
           }
        }
        else if(SampleCount >= locset[locsetid]&& SampleCount < locset[locsetid+1])
        {
            if (dataIN & 0x800)
                dataIN |= ~(0xfff); //negative  data, make all the high bit(12 and after) 1
            else dataIN &= 0xfff;        //positive data, make all the hight bit 0

            //int delay = qrsdet.QRSDetFront(dataIN);
            int tmp=qrsbuf[bufID];
            qrsbuf[bufID++] = dataIN;
            if(bufID == SPECQRS_lGTH)//
                bufID = 0;
            if(SampleCount >=(locatebegin+SPECQRS_lGTH)){
                k=bufID;
                for(int i=0;i<SPECQRS_lGTH;i++) {
                    locdn[i]= qrsbuf[k++];
                    if(k==SPECQRS_lGTH)
                        k=0;
                }
                //compute the sum
                sumloc = 0;
                if(SampleCount ==locatebegin+SPECQRS_lGTH){
                    for(int i=0;i<SPECQRS_lGTH;i++){
                        sumloc += locdn[i];
                    }
                }
                else{
                    //sumloc = sumloc - tmp + dataIN;
                    for(int i=0;i<SPECQRS_lGTH;i++){
                        sumloc += locdn[i];
                    }
                }
                //
                meanloc = sumloc/SPECQRS_lGTH;
                s1 = 0;
                s = 0;
                rscore[0] = rscore[1];
                rscore[1]=rscore[2];
                for(int i=0;i<SPECQRS_lGTH;i++){
                    locdis[i] = locdn[i] - meanloc;
                    s1 += locdis[i]*locdis[i];
                    s += locdis[i]*specdis[i];
                }
                rscore[2] = s/sqrt(s1*s2);

                if(rscore[1]>0.9 && rscore[1]>rscore[0]&&rscore[1]>rscore[2]){
                    locatespecial->push_back(SampleCount);
                   // printf("%d\t%d\t%f\t%f\n",locatespecial->size(),SampleCount-51,rscore[1],rscore[2]);
                }
            }

        }

        ++SampleCount;
    }

    delete[]lpc;
    fclose(filed);

    return 1;
}

bool TESTRECORD::compareQRS(char* qrsbuf,char* specbuf)
{
    int maxdn = 0, maxId = 0;
    int mindn = 0, minId = 0;
    int dis = 0;
    int basicline = 0;
    double sum = 0;
    for(int i=0;i<31;i++){
        sum += specbuf[i];
    }
    double mean = sum/31;
    double summean = 0;
    for(int i=0;i<31;i++){
        summean += (specbuf[i] - mean)*(specbuf[i] - mean);
    }

    return false;
}

char *get_file_name(const char *path) {
    char *ssc;
    int l = 0;
    char *name = (char *) path;
    ssc = strstr(name, "/");
    while (ssc) {
        l = strlen(ssc) + 1;
        name = &name[strlen(name) - l + 2];
        ssc = strstr(name, "/");
    };
    return name;
}

void remove_extension(char* path) {
    for (int i = (int) strlen(path) - 1; i > 0; i--) {
        if (path[i] == '.') {
            path[i] = 0;
            return;
        }
    }
}

int TESTRECORD::TestRecord__edf(const char *data_file_path)
{
    char *data_file_name;
    char date_tmp[_MAX_PATH]; //XXX/201414/
    char ecg_file_name[_MAX_PATH];
    char date_path[_MAX_PATH];
    char ecg_filtered_data_file_path[_MAX_PATH]; //saved file name
    char ecg_annotation_file_path[_MAX_PATH]; //saved file name
    char ecg_head_file_path[_MAX_PATH]; //saved file name           7
    char ecg_tmp_file_path[_MAX_PATH]; //saved file name           7
   // char ecg_config_file_path[_MAX_PATH];// the path with config
    //get the read 1-channal-dat and write 2-channal-dat path
    string WRITE_PATH,READ_PATH;
    conf::Instance()->Load(SYS_CONF);
    conf::Instance()->Get("write_path", WRITE_PATH);
    conf::Instance()->Get("read_path", READ_PATH);
    //get the filename and the last foldername
    memset(date_tmp, 0, _MAX_PATH);
    data_file_name = get_file_name(data_file_path);
    strncpy(ecg_file_name, data_file_name,_MAX_PATH);
    remove_extension(ecg_file_name);
    strncpy(date_tmp, data_file_path, strlen(data_file_path) - strlen(data_file_name) - 1);
    strncpy(date_path, get_file_name(date_tmp),_MAX_PATH);
    //get the full file path
    snprintf(ecg_filtered_data_file_path,_MAX_PATH, "%s/%s/%s.dat", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_annotation_file_path,_MAX_PATH, "%s/%s/%s.bsp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_head_file_path,_MAX_PATH, "%s/%s/%s.hea", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_tmp_file_path,_MAX_PATH, "%s/%s/%s.tmp", WRITE_PATH.c_str(), date_path, ecg_file_name);
   // snprintf(ecg_config_file_path,_MAX_PATH, "%s/%s/%s.cnf", READ_PATH.c_str(), date_path, ecg_file_name);
    //variable initial
    Initial();
    //use the google_protobuf
    GOOGLE_PROTOBUF_VERIFY_VERSION;
    //Template tmp;
    temp::BeatTemplate *tmpN=tmp.add_beat_templates();
    temp::BeatTemplate *tmpA=tmp.add_beat_templates();
    temp::BeatTemplate *tmpV=tmp.add_beat_templates();
    tmpA->set_type(BeatTemplate::A);
    tmpN->set_type(BeatTemplate::N);
    tmpV->set_type(BeatTemplate::V);
    //using in tmp
    int modeltypev[MAXTYPES+1];
    int modeltypen[MAXTYPES+1];
    for(int i=0;i<MAXTYPES+1;i++)
    {
        modeltypev[i] = 0;
        modeltypen[i] = 0;
    }
    std::vector< std::vector<int> > m_clusters;
    std::vector<int> m_type;
    std::vector<int> Q_type;
    //write to annot
    WFDB_Annotation annot ;
    FILE *fileann = fopen(ecg_annotation_file_path,"wb");//

    //find QRS
    int delay;
    int InputFileSampleFrequency = SAMPLE_RATE;
    long SampleCount = 0;
    long DetectionTime = 0;
    int beatType, beatMatch ;
    lasttime =0;


    // Open a 1 channel record
    FILE* filed = fopen(data_file_path,"r");//
    if(!filed){
        printf("please check the file:%s!",data_file_path);
        return 0;
    }
    fseek(filed,0,2);
    long flend=ftell(filed); // 得到文件大小
    int lengthd = flend/(sizeof(int)/sizeof(char));
    int posd=0;              // read the 1-channal-locate, once by 3 chars
    //int* lpc = new int[lengthd]; //read
    int* INlpc = new int[lengthd];//the real data in 1-channal-file
    int* OUTlpc = new int[lengthd];//the real data in 2-channal-file
    fseek(filed, 0, SEEK_SET);
    fread(INlpc, lengthd,sizeof(int)/sizeof(char),filed);
    int dataIN;

    //write to the 2-channal-dat file
    int file2c_lsize = lengthd*2;
    FILE* fp = fopen(ecg_filtered_data_file_path,"w");
    if (fp == NULL){
        printf("can't open the output 2-channel file!");
        return 0;
    }
    int *buf = new int[file2c_lsize];//(char *) malloc(file2c_lsize);
    int* lpc2 = (int *) buf;

    //write the head file
    FILE *filehea = fopen(ecg_head_file_path, "w");
    int sNum = 2;
    float sr = SAMPLE_RATE;
    int res = fprintf(filehea, "%s %d %3.0f %d\n", ecg_file_name, sNum, sr, file2c_lsize);
    int eNum = 0;
    int umv = 549, bits = 232, resolution = 12, zero = 0, crc = 0, firstdata = 0;
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s\n", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    fclose(filehea);

    int delnum=0;
    // Initialize beat detection and classification.
    BDAC bdac;
    bdac.ResetBDAC() ;                                                   //bdac.c
    int lpcount = 0;

    double Fs = SAMPLE_RATE;//采样频率
    double T = 1/Fs;//采样间隔
    int L2=36;
    int nfft = nextPowerOf2(L2);

    double dataL[36];// = {-22,11,30,36,30,24,18,11,4,-1,-1,2,8,15,26,41,54,41,-5,-65,-100,-91,-52,-10,15,26,27,22,15,10,7,6,5,3,2,1};
    double* dataind2 = new double[nfft];
    double* datafftr2 = new double[nfft];
    double* dataffti2 = new double[nfft];
    double* coskn = new double[nfft*nfft];
    double* sinkn = new double[nfft*nfft];
    int num = -nfft;
    for(int i=0;i<nfft;i++) {
        dataind2[i] = 0.0;
        datafftr2[i] = 0.0;
        dataffti2[i] = 0.0;
        num += nfft;
        for(int k=0;k<nfft;k++)
        {
            coskn[num+k] = cos(2*PI*k*i/nfft);
            sinkn[num+k] = sin(2*PI*k*i/nfft);
        }
    }

    // Read data from MIT/BIH file until tre is none left.
    while( posd < lengthd)  //local
    {
        dataIN = INlpc[posd];
        posd++;


        /*if (dataIN & 0x800)
            dataIN |= ~(0xfff); //negative  data, make all the high bit(12 and after) 1
        else dataIN &= 0xfff;        //positive data, make all the hight bit 0
         */
        ++SampleCount ;
        // Pass sample to beat detection and classification.
        delay = bdac.BeatDetectAndClassify(dataIN, &beatType, &beatMatch) ;    //bdac.c
        //save the real-data
        OUTlpc[lpcount] =bdac.qrsdet1.datafilt;
        lpcount++;
        //INlpc[lpcount++] = dataIN;
        // printf("%d\n",SampleCount);
        // If a beat was detected, annotate the beat location and type.
        if(delay != 0)
        {
            DetectionTime = SampleCount - delay ;

            int maxfiltdn = 0;
            int maxid = 0;
            int id = 0;
            for(int i=5;i<41;i++)
            {
                id = bdac.ECGBufferIndex-delay+i-9;//35+26;
                if(id<0)
                    id += ECG_BUFFER_LENGTH;
                if(id>=ECG_BUFFER_LENGTH)
                    id -= ECG_BUFFER_LENGTH;
                dataL[i-5] = bdac.ECGBufferfilt[id];
                if(bdac.ECGBufferfilt[id]>maxfiltdn)
                {
                    maxfiltdn = bdac.ECGBufferfilt[id];
                    maxid = i;
                }
            }
            if(maxid >5&& maxid<31)
                DetectionTime +=maxid-18;
            for(int i=0;i<L2;i++){
                dataind2[i] = dataL[i];
            }

            //DFT(dataind,datafft,datafft,nfft);
            DFT2(dataind2,datafftr2,dataffti2,nfft,coskn,sinkn);
            double datafftout= sqrt(pow(datafftr2[5]/36,2) + pow(dataffti2[5]/36,2));

//            for(int i=0;i<L2;i++){
//                datafftout[i] = sqrt(pow(abs(datafft[i].real())/36,2) + pow(abs(datafft[i].imag()/36),2));
//            }
            //printf("%f\n",datafftout);
            //threshold of pinyu and not comerge the tmp and not create the tmp
            //want to add a threshold ,for example the counts of cross zero
            if((datafftout<8||datafftout>100) && bdac.match1.CombineInType==-1&&bdac.match1.lastBeatWasNew != 1 ) {
                beatType = 13;
            }

            // Convert sample count to input file sample rate.
            DetectionTime *= InputFileSampleFrequency ;
            DetectionTime /= SAMPLE_RATE ;
            if(annot.time >= DetectionTime){
                continue;
            }
            annot.time = DetectionTime ;
            annot.anntyp = beatType ;
            annot.aux = NULL ;
            putann2(fileann, &annot, lasttime, 0);
            //WRITE TO THE TMP
            WRITE_THE_TMP(beatType, bdac, m_clusters, m_type, Q_type, DetectionTime, modeltypen, modeltypev,&delnum);
        }
    }

    delete[]dataind2;
    delete[]datafftr2;
    delete[]dataffti2;
    delete[]sinkn;
    delete[]coskn;

    //2 int change to 3 chars
    int dif = LPBUFFER_LGTH/2-1+(HPBUFFER_LGTH-1)/2;
    for(int i=0;i<lengthd;i++)
    {
        lpc2[0] = INlpc[i];
        lpc2[1] = OUTlpc[i];
        lpc2 += 2;
    }
    fwrite( buf, sizeof(int), file2c_lsize, fp);
    fclose(fp);//close the 2-channal-dat file
    delete[]buf;
    //delete[]lpc;
    delete[]INlpc;
    delete[]OUTlpc;
    //
    //printf("Record:%s,%d,%d\n",data_file_name,m_type.size(),delnum);
    wfdb_p16(0, fileann);//STOP WRITE THE ATEST FILE
    fclose(fileann);//CLOSE WRITE THE annotion FILE
    fclose(filed); //CLOSE THE 1-channal-DAT FILE

    // Write the new address book back to disk.
    int Nnum = 0, Vnum=0, Anum = 0;
    int countN = 0,countV = 0,countA=0;
    bool Nfind1 = false, Vfind1 = false, Afind1 = false;
    int Nfind1ID = 0, Vfind1ID = 0, Afind1ID = 0;
    fstream tempfile(ecg_tmp_file_path, ios::out | ios::trunc | ios::binary);
    Template1 *tmp1N = tmpN->add_template1s();
    tmp1N->set_id(0);
    Template1 *tmp1V = tmpV->add_template1s();
    tmp1V->set_id(0);
    Template1 *tmp1A = tmpA->add_template1s();
    tmp1A->set_id(0);

    if (Q_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1A->add_template2s();
        tmp1->set_id(0);
        countA += Q_type.size();
        for (int k = 0; k < Q_type.size(); k++) {
            tmp1->add_positions_of_beats(Q_type[k]);
        }
    }
    for (int j = 0; j < m_type.size(); ++j) {
        int type = m_type[j];
        if(!m_clusters[j].size())
            continue;

        Template2 *tmp1;
        int numID = 0;
        if (1 == type) {
            if (m_clusters[j].size() > MERRGENUM) {
                tmp1 = tmp1N->add_template2s();
                tmp1->set_id(0);
                numID = Nnum++;
                countN += m_clusters[j].size();
                for (int k = 0; k < m_clusters[j].size(); k++) {
                    tmp1->add_positions_of_beats(m_clusters[j][k]);
                }
            }
            else {
                if (!Nfind1) {
                    Nfind1 = true;
                    Nfind1ID = j;
                }
                for (int k = 0; k < MERRGENUM; ++k) {
                    m_clusters[Nfind1ID].push_back(m_clusters[j][k]);
                }
            }
        }
        else if (5 == type)
        {
            if (m_clusters[j].size() > MERRGENUM) {
                tmp1 = tmp1V->add_template2s();
                numID = Vnum++;
                countV += m_clusters[j].size();
                for (int k = 0; k < m_clusters[j].size(); k++) {
                    tmp1->add_positions_of_beats(m_clusters[j][k]);
                }
            }
            else {
                if (!Vfind1) {
                    Vfind1 = true;
                    Vfind1ID = j;
                }
                for (int k = 0; k < MERRGENUM; ++k) {
                    m_clusters[Vfind1ID].push_back(m_clusters[j][k]);
                }

            }
        }
        else {
            if (m_clusters[j].size() > MERRGENUM) {
                tmp1 = tmp1A->add_template2s();
                numID = Anum++;
                countA += m_clusters[j].size();
            }
            else {
                if (!Afind1) {
                    Afind1 = true;
                    Afind1ID = j;
                }

                for (int k = 0; k < MERRGENUM; ++k) {
                    m_clusters[Afind1ID].push_back(m_clusters[j][k]);
                }
            }
        }
    }
    if(Nfind1 == true) {
        int numID = Nnum++;
        countN += m_clusters[Nfind1ID].size();
        Template2 *tmp2 = tmp1N->add_template2s();
        tmp2->set_id(0);
        for(int k=0;k<m_clusters[Nfind1ID].size();k++) {
            tmp2->add_positions_of_beats(m_clusters[Nfind1ID][k]);
        }
    }
    if(Vfind1 == true) {
        int numID = Vnum++;
        countV += m_clusters[Vfind1ID].size();
        Template2 *tmp2 = tmp1V->add_template2s();
        tmp2->set_id(0);//numID);
        for(int k=0;k<m_clusters[Vfind1ID].size();k++) {
            tmp2->add_positions_of_beats(m_clusters[Vfind1ID][k]);
        }
    }
    if(Afind1 == true)
    {
        int numID = Anum++;
        countA += m_clusters[Afind1ID].size();
        Template2 *tmp2 = tmp1A->add_template2s();
        tmp2->set_id(0);//numID);
        for(int k=0;k<m_clusters[Afind1ID].size();k++) {
            tmp2->add_positions_of_beats(m_clusters[Afind1ID][k]);
        }
    }
    printf("all tmp = %d\n", Anum + Vnum +Nnum);
    if (!tmp.SerializeToOstream(&tempfile)) {
        cerr << "Failed to write address book." << endl;
        return -1;
    }
    google::protobuf::ShutdownProtobufLibrary();

    return 0;
}

int TESTRECORD::TestRecord__edf_short(const char *data_file_path)
{
    char *data_file_name;
    char date_tmp[_MAX_PATH]; //XXX/201414/
    char ecg_file_name[_MAX_PATH];
    char date_path[_MAX_PATH];
    char ecg_filtered_data_file_path[_MAX_PATH]; //saved file name
    char ecg_annotation_file_path[_MAX_PATH]; //saved file name
    char ecg_head_file_path[_MAX_PATH]; //saved file name           7
    char ecg_tmp_file_path[_MAX_PATH]; //saved file name           7
   // char ecg_config_file_path[_MAX_PATH];// the path with config
    //get the read 1-channal-dat and write 2-channal-dat path
    string WRITE_PATH,READ_PATH;
    conf::Instance()->Load(SYS_CONF);
    conf::Instance()->Get("write_path", WRITE_PATH);
    conf::Instance()->Get("read_path", READ_PATH);
    //get the filename and the last foldername
    memset(date_tmp, 0, _MAX_PATH);
    data_file_name = get_file_name(data_file_path);
    strncpy(ecg_file_name, data_file_name,_MAX_PATH);
    remove_extension(ecg_file_name);
    strncpy(date_tmp, data_file_path, strlen(data_file_path) - strlen(data_file_name) - 1);
    strncpy(date_path, get_file_name(date_tmp),_MAX_PATH);
    //get the full file path
    snprintf(ecg_filtered_data_file_path,_MAX_PATH, "%s/%s/%s.dat", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_annotation_file_path,_MAX_PATH, "%s/%s/%s.bsp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_head_file_path,_MAX_PATH, "%s/%s/%s.hea", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_tmp_file_path,_MAX_PATH, "%s/%s/%s.tmp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    //snprintf(ecg_config_file_path,_MAX_PATH, "%s/%s/%s.cnf", READ_PATH.c_str(), date_path, ecg_file_name);
    //variable initial
    Initial();
    //use the google_protobuf
    GOOGLE_PROTOBUF_VERIFY_VERSION;
    //Template tmp;
    temp::BeatTemplate *tmpN=tmp.add_beat_templates();
    temp::BeatTemplate *tmpA=tmp.add_beat_templates();
    temp::BeatTemplate *tmpV=tmp.add_beat_templates();
    tmpA->set_type(BeatTemplate::A);
    tmpN->set_type(BeatTemplate::N);
    tmpV->set_type(BeatTemplate::V);
    //using in tmp
    int modeltypev[MAXTYPES+1];
    int modeltypen[MAXTYPES+1];
    for(int i=0;i<MAXTYPES+1;i++)
    {
        modeltypev[i] = 0;
        modeltypen[i] = 0;
    }
    std::vector< std::vector<int> > m_clusters;
    std::vector<int> m_type;
    std::vector<int> Q_type;
    //write to annot
    WFDB_Annotation annot ;
    FILE *fileann = fopen(ecg_annotation_file_path,"wb");//

    //find QRS
    int delay;
    int InputFileSampleFrequency = SAMPLE_RATE;
    long SampleCount = 0;
    long DetectionTime = 0;
    int beatType, beatMatch ;
    lasttime =0;


    // Open a 1 channel record
    FILE* filed = fopen(data_file_path,"r");//
    if(!filed){
        printf("please check the file:%s!",data_file_path);
        return 0;
    }
    fseek(filed,0,2);
    long flend=ftell(filed); // 得到文件大小
    int lengthd = flend/(sizeof(short)/sizeof(char));
    int posd=0;              // read the 1-channal-locate, once by 3 chars
    //int* lpc = new int[lengthd]; //read
    short* INlpc = new short[lengthd];//the real data in 1-channal-file
    short* OUTlpc = new short[lengthd];//the real data in 2-channal-file
    fseek(filed, 0, SEEK_SET);
    fread(INlpc, lengthd,sizeof(short)/sizeof(char),filed);
    int dataIN;

    //write to the 2-channal-dat file
    int file2c_lsize = lengthd*3;
    FILE* fp = fopen(ecg_filtered_data_file_path,"w");
    if (fp == NULL){
        printf("can't open the output 2-channel file!");
        return 0;
    }
    char *buf = new char[file2c_lsize];//(char *) malloc(file2c_lsize);
    char* lpc2 = (char *) buf;

    //write the head file
    FILE *filehea = fopen(ecg_head_file_path, "w");
    int sNum = 2;
    float sr = SAMPLE_RATE;
    int res = fprintf(filehea, "%s %d %3.0f %d\n", ecg_file_name, sNum, sr, file2c_lsize);
    int eNum = 0;
    int umv = 549, bits = 232, resolution = 12, zero = 0, crc = 0, firstdata = 0;
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s\n", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    fclose(filehea);

    int delnum=0;
    // Initialize beat detection and classification.
    BDAC bdac;
    bdac.ResetBDAC() ;                                                   //bdac.c
    int lpcount = 0;

    /*double Fs = SAMPLE_RATE;//采样频率
    double T = 1/Fs;//采样间隔
    int L2=36;
    int nfft = nextPowerOf2(L2);

    double dataL[36];// = {-22,11,30,36,30,24,18,11,4,-1,-1,2,8,15,26,41,54,41,-5,-65,-100,-91,-52,-10,15,26,27,22,15,10,7,6,5,3,2,1};
    double* dataind2 = new double[nfft];
    double* datafftr2 = new double[nfft];
    double* dataffti2 = new double[nfft];
    double* coskn = new double[nfft*nfft];
    double* sinkn = new double[nfft*nfft];
    int num = -nfft;
    for(int i=0;i<nfft;i++) {
        dataind2[i] = 0.0;
        datafftr2[i] = 0.0;
        dataffti2[i] = 0.0;
        num += nfft;
        for(int k=0;k<nfft;k++)
        {
            coskn[num+k] = cos(2*PI*k*i/nfft);
            sinkn[num+k] = sin(2*PI*k*i/nfft);
        }
    }*/

    // Read data from MIT/BIH file until tre is none left.
    while( posd < lengthd)  //local
    {
        dataIN = (int)INlpc[posd];
        posd++;


        /*if (dataIN & 0x800)
            dataIN |= ~(0xfff); //negative  data, make all the high bit(12 and after) 1
        else dataIN &= 0xfff;        //positive data, make all the hight bit 0
         */
        ++SampleCount ;
        // Pass sample to beat detection and classification.
        delay = bdac.BeatDetectAndClassify(dataIN, &beatType, &beatMatch) ;    //bdac.c
        //save the real-data
        OUTlpc[lpcount] =(short)bdac.qrsdet1.datafilt;
        lpcount++;
        //INlpc[lpcount++] = dataIN;
        // printf("%d\n",SampleCount);
        // If a beat was detected, annotate the beat location and type.
        if(delay != 0)
        {
            DetectionTime = SampleCount - delay ;

           /* int maxfiltdn = 0;
            int maxid = 0;
            int id = 0;
            for(int i=5;i<41;i++)
            {
                id = bdac.ECGBufferIndex-delay+i-35+26;
                if(id<0)
                    id += ECG_BUFFER_LENGTH;
                if(id>=ECG_BUFFER_LENGTH)
                    id -= ECG_BUFFER_LENGTH;
                dataL[i-5] = bdac.ECGBufferfilt[id];
                if(bdac.ECGBufferfilt[id]>maxfiltdn)
                {
                    maxfiltdn = bdac.ECGBufferfilt[id];
                    maxid = i;
                }
            }
            if(maxid >5&& maxid<31)
                DetectionTime +=maxid-18;
            for(int i=0;i<L2;i++){
                dataind2[i] = dataL[i];
            }

            //DFT(dataind,datafft,datafft,nfft);
            DFT2(dataind2,datafftr2,dataffti2,nfft,coskn,sinkn);
            double datafftout= sqrt(pow(datafftr2[5]/36,2) + pow(dataffti2[5]/36,2));

//            for(int i=0;i<L2;i++){
//                datafftout[i] = sqrt(pow(abs(datafft[i].real())/36,2) + pow(abs(datafft[i].imag()/36),2));
//            }
            //printf("%f\n",datafftout);
            //threshold of pinyu and not comerge the tmp and not create the tmp
            //want to add a threshold ,for example the counts of cross zero
            if((datafftout<8||datafftout>100) && bdac.match1.CombineInType==-1&&bdac.match1.lastBeatWasNew != 1 ) {
                beatType = 13;
            }
*/
            // Convert sample count to input file sample rate.
            DetectionTime *= InputFileSampleFrequency ;
            DetectionTime /= SAMPLE_RATE ;
            if(annot.time>=DetectionTime){
                continue;
            }
            annot.time = DetectionTime ;
            annot.anntyp = beatType ;
            annot.aux = NULL ;
            putann2(fileann,&annot,lasttime,0);
            //WRITE TO THE TMP
            WRITE_THE_TMP(beatType, bdac, m_clusters, m_type, Q_type, DetectionTime, modeltypen, modeltypev,&delnum);
        }
    }

   // delete[]dataind2;
 //   delete[]datafftr2;
 //   delete[]dataffti2;
//    delete[]sinkn;
//    delete[]coskn;
//
    //2 int change to 3 chars
    int dif = LPBUFFER_LGTH/2-1+(HPBUFFER_LGTH-1)/2;
    for(int i=0;i<lengthd;i++)
    {
        int id = i+dif;
        if(id>=lengthd){
            id=lengthd-1;
        }
        lpc2[0] = LOBYTE((short) INlpc[i]);
        lpc2[1] = 0;
        lpc2[1] = HIBYTE((short) INlpc[i]) & 0x0f;
        lpc2[2] = LOBYTE((short) OUTlpc[id]);
        lpc2[1] |= HIBYTE((short) OUTlpc[id]) << 4;
        lpc2 += 3;
    }
    fwrite( buf, sizeof(int), file2c_lsize, fp);
    fclose(fp);//close the 2-channal-dat file
    delete[]buf;
    //delete[]lpc;
    delete[]INlpc;
    delete[]OUTlpc;
    //
    //printf("Record:%s,%d,%d\n",data_file_name,m_type.size(),delnum);
    wfdb_p16(0, fileann);//STOP WRITE THE ATEST FILE
    fclose(fileann);//CLOSE WRITE THE annotion FILE
    fclose(filed); //CLOSE THE 1-channal-DAT FILE

    // Write the new address book back to disk.
    int Nnum = 0, Vnum=0, Anum = 0;
    int countN = 0,countV = 0,countA=0;
    bool Nfind1 = false, Vfind1 = false, Afind1 = false;
    int Nfind1ID = 0, Vfind1ID = 0, Afind1ID = 0;
    fstream tempfile(ecg_tmp_file_path, ios::out | ios::trunc | ios::binary);
    Template1 *tmp1N = tmpN->add_template1s();
    tmp1N->set_id(0);
    Template1 *tmp1V = tmpV->add_template1s();
    tmp1V->set_id(0);
    Template1 *tmp1A = tmpA->add_template1s();
    tmp1A->set_id(0);

    if (Q_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1A->add_template2s();
        tmp1->set_id(0);
        countA += Q_type.size();
        for (int k = 0; k < Q_type.size(); k++) {
            tmp1->add_positions_of_beats(Q_type[k]);
        }
    }
    for (int j = 0; j < m_type.size(); ++j) {
        int type = m_type[j];
        if(!m_clusters[j].size())
            continue;

        Template2 *tmp1;
        int numID = 0;
        if (1 == type) {
            if (m_clusters[j].size() > MERRGENUM) {
                tmp1 = tmp1N->add_template2s();
                tmp1->set_id(0);
                numID = Nnum++;
                countN += m_clusters[j].size();
                for (int k = 0; k < m_clusters[j].size(); k++) {
                    tmp1->add_positions_of_beats(m_clusters[j][k]);
                }
            }
            else {
                if (!Nfind1) {
                    Nfind1 = true;
                    Nfind1ID = j;
                }
                for (int k = 0; k < MERRGENUM; ++k) {
                    m_clusters[Nfind1ID].push_back(m_clusters[j][k]);
                }
            }
        }
        else if (5 == type)
        {
            if (m_clusters[j].size() > MERRGENUM) {
                tmp1 = tmp1V->add_template2s();
                numID = Vnum++;
                countV += m_clusters[j].size();
                for (int k = 0; k < m_clusters[j].size(); k++) {
                    tmp1->add_positions_of_beats(m_clusters[j][k]);
                }
            }
            else {
                if (!Vfind1) {
                    Vfind1 = true;
                    Vfind1ID = j;
                }
                for (int k = 0; k < MERRGENUM; ++k) {
                    m_clusters[Vfind1ID].push_back(m_clusters[j][k]);
                }

            }
        }
        else {
            if (m_clusters[j].size() > MERRGENUM) {
                tmp1 = tmp1A->add_template2s();
                numID = Anum++;
                countA += m_clusters[j].size();
            }
            else {
                if (!Afind1) {
                    Afind1 = true;
                    Afind1ID = j;
                }

                for (int k = 0; k < MERRGENUM; ++k) {
                    m_clusters[Afind1ID].push_back(m_clusters[j][k]);
                }
            }
        }
    }
    if(Nfind1 == true) {
        int numID = Nnum++;
        countN += m_clusters[Nfind1ID].size();
        Template2 *tmp2 = tmp1N->add_template2s();
        tmp2->set_id(0);
        for(int k=0;k<m_clusters[Nfind1ID].size();k++) {
            tmp2->add_positions_of_beats(m_clusters[Nfind1ID][k]);
        }
    }
    if(Vfind1 == true) {
        int numID = Vnum++;
        countV += m_clusters[Vfind1ID].size();
        Template2 *tmp2 = tmp1V->add_template2s();
        tmp2->set_id(0);//numID);
        for(int k=0;k<m_clusters[Vfind1ID].size();k++) {
            tmp2->add_positions_of_beats(m_clusters[Vfind1ID][k]);
        }
    }
    if(Afind1 == true)
    {
        int numID = Anum++;
        countA += m_clusters[Afind1ID].size();
        Template2 *tmp2 = tmp1A->add_template2s();
        tmp2->set_id(0);//numID);
        for(int k=0;k<m_clusters[Afind1ID].size();k++) {
            tmp2->add_positions_of_beats(m_clusters[Afind1ID][k]);
        }
    }
    printf("all tmp = %d\n", Anum + Vnum +Nnum);
    if (!tmp.SerializeToOstream(&tempfile)) {
        cerr << "Failed to write address book." << endl;
        return -1;
    }
    google::protobuf::ShutdownProtobufLibrary();

    return 0;
}

int TESTRECORD::TestRecord_read_save(const char *data_file_path)
{
    char *data_file_name;
    char date_tmp[_MAX_PATH]; //XXX/201414/
    char ecg_file_name[_MAX_PATH];
    char date_path[_MAX_PATH];
    char ecg_filtered_data_file_path[_MAX_PATH]; //saved file name

    //get the read 1-channal-dat and write 2-channal-dat path
    string WRITE_PATH,READ_PATH;
    conf::Instance()->Load(SYS_CONF);
    conf::Instance()->Get("write_path", WRITE_PATH);
    conf::Instance()->Get("read_path", READ_PATH);
    //get the filename and the last foldername
    memset(date_tmp, 0, _MAX_PATH);
    data_file_name = get_file_name(data_file_path);
    strncpy(ecg_file_name, data_file_name,_MAX_PATH);
    remove_extension(ecg_file_name);
    strncpy(date_tmp, data_file_path, strlen(data_file_path) - strlen(data_file_name) - 1);
    strncpy(date_path, get_file_name(date_tmp),_MAX_PATH);
    //get the full file path
    snprintf(ecg_filtered_data_file_path,_MAX_PATH, "%s/%s/%s.dat", WRITE_PATH.c_str(), date_path, ecg_file_name);
    //variable initial
    Initial();

    //find QRS
    int delay;
    int InputFileSampleFrequency = 128;
    long SampleCount = 0;
    long DetectionTime = 0;
    int beatType, beatMatch ;
    lasttime =0;


    // Open a 1 channel record
    FILE* filed = fopen(data_file_path,"r");//
    if(!filed){
        printf("please check the file:%s!",data_file_path);
        return 0;
    }
    fseek(filed,0,2);
    long flend=ftell(filed); // 得到文件大小
    int lengthd = flend/3;
    int posd=0;              // read the 1-channal-locate, once by 3 chars
    char* lpc = new char[flend]; //read
    int* INlpc = new int[lengthd*2];//the real data in 1-channal-file
    int* OUTlpc = new int[lengthd*2];//the real data in 2-channal-file
    fseek(filed, 0, SEEK_SET);
    fread(lpc, flend,1,filed);
    int dataIN;

    int delnum=0;
    // Initialize beat detection and classification.
    BDAC bdac;
    bdac.ResetBDAC() ;                                                   //bdac.c
    int lpcount = 0;
    FILE* file_data=fopen("fdata.txt","a");
    // Read data from MIT/BIH file until tre is none left.
    while( posd < lengthd)  //local
    {
        if(SampleCount%2==0) {
            dataIN = MAKEWORD(lpc[posd * 3 ], (lpc[posd * 3 + 1 ] & 0x0f));
        }
        else {
            dataIN = MAKEWORD(lpc[posd * 3 + 2], (lpc[posd * 3 + 1] & 0xf0) >> 4);
            posd++;
        }

        if (dataIN & 0x800)
            dataIN |= ~(0xfff); //negative  data, make all the high bit(12 and after) 1
        else dataIN &= 0xfff;        //positive data, make all the hight bit 0
        fprintf(file_data,"%d\n",dataIN);
        ++SampleCount ;
        // Pass sample to beat detection and classification.
        delay = bdac.BeatDetectAndClassify(dataIN, &beatType, &beatMatch) ;    //bdac.c
    }
    fclose(file_data);
    fclose(filed);

    return 0;
}

struct data_qrs{
    int wid;  // 宽度，从最大值到两边最小值的范围
    int maxd; // 最大值
    int maxid;//最大值位置
    int mind; //最小值
    int minid; //最小值位置
    int Hall;  //高度范围
    int count0;//过0点个数
    int demax;//一阶最大值

};

void checkqrs(int* data,int* de,int* deabs,data_qrs* qrs);

int TESTRECORD::TestRecord_qrs(const char *data_file_path)
{
    char *data_file_name;
    char date_tmp[_MAX_PATH]; //XXX/201414/
    char ecg_file_name[_MAX_PATH];
    char date_path[_MAX_PATH];
    char ecg_filtered_data_file_path[_MAX_PATH]; //saved file name
    char ecg_annotation_file_path[_MAX_PATH]; //saved file name
    char ecg_head_file_path[_MAX_PATH]; //saved file name           7
    char ecg_tmp_file_path[_MAX_PATH]; //saved file name           7
    char ecg_config_file_path[_MAX_PATH];// the path with config
    //get the read 1-channal-dat and write 2-channal-dat path
    string WRITE_PATH,READ_PATH;
    conf::Instance()->Load(SYS_CONF);
    conf::Instance()->Get("write_path", WRITE_PATH);
    conf::Instance()->Get("read_path", READ_PATH);
    //get the filename and the last foldername
    memset(date_tmp, 0, _MAX_PATH);
    data_file_name = get_file_name(data_file_path);
    strncpy(ecg_file_name, data_file_name,_MAX_PATH);
    remove_extension(ecg_file_name);
    strncpy(date_tmp, data_file_path, strlen(data_file_path) - strlen(data_file_name) - 1);
    strncpy(date_path, get_file_name(date_tmp),_MAX_PATH);
    //get the full file path
    snprintf(ecg_filtered_data_file_path,_MAX_PATH, "%s/%s/%s.dat", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_annotation_file_path,_MAX_PATH, "%s/%s/%s.bsp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_head_file_path,_MAX_PATH, "%s/%s/%s.hea", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_tmp_file_path,_MAX_PATH, "%s/%s/%s.tmp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_config_file_path,_MAX_PATH, "%s/%s/%s.cnf", READ_PATH.c_str(), date_path, ecg_file_name);
    //variable initial
    Initial();
    //use the google_protobuf
    GOOGLE_PROTOBUF_VERIFY_VERSION;
    //Template tmp;
    temp::BeatTemplate *tmpN=tmp.add_beat_templates();
    temp::BeatTemplate *tmpA=tmp.add_beat_templates();
    temp::BeatTemplate *tmpV=tmp.add_beat_templates();
    temp::BeatTemplate *tmpS=tmp.add_beat_templates();
    tmpA->set_type(BeatTemplate::A);
    tmpN->set_type(BeatTemplate::N);
    tmpV->set_type(BeatTemplate::V);
    tmpS->set_type(BeatTemplate::S);
    //using in tmp
    int modeltypev[MAXTYPES+1];
    int modeltypen[MAXTYPES+1];
    for(int i=0;i<MAXTYPES+1;i++)
    {
        modeltypev[i] = 0;
        modeltypen[i] = 0;
    }
    std::vector< std::vector<int> > m_clusters;
    std::vector<int> m_type;
    std::vector<int> Q_type;
    std::vector<int> S_type;
    std::vector<int> V_type;
    //write to annot
    WFDB_Annotation annotppre ;
    WFDB_Annotation annotpre ;
    WFDB_Annotation annot ;
    FILE *fileann = fopen(ecg_annotation_file_path,"wb");//

    //find QRS
    int delay = 45;
    int InputFileSampleFrequency = 128;
    long SampleCount = 0;
    long DetectionTime = 0;
    int beatType=13, beatMatch=0 ;
    lasttime =0;


    // Open a 1 channel record
    FILE* filed = fopen(data_file_path,"r");//
    if(!filed){
        printf("please check the file:%s!",data_file_path);
        return 0;
    }
    fseek(filed,0,2);
    long flend=ftell(filed); // 得到文件大小
    int lengthd = flend/3;
    int posd=0;              // read the 1-channal-locate, once by 3 chars
    char* lpc = new char[flend]; //read
    int* INlpc = new int[lengthd*2];//the real data in 1-channal-file
    int* OUTlpc = new int[lengthd*2];//the real data in 2-channal-file
    fseek(filed, 0, SEEK_SET);
    fread(lpc, flend,1,filed);
    int dataIN;

    //write to the 2-channal-dat file
    int file2c_lsize = flend*2;
    FILE* fp = fopen(ecg_filtered_data_file_path,"w");
    if (fp == NULL){
        printf("can't open the output 2-channel file!");
        return 0;
    }
    char *buf = new char[file2c_lsize];//(char *) malloc(file2c_lsize);
    char* lpc2 = (char *) buf;

    //write the head file
    FILE *filehea = fopen(ecg_head_file_path, "w");
    int sNum = 2;
    float sr = 128;
    int res = fprintf(filehea, "%s %d %3.0f %d\n", ecg_file_name, sNum, sr, file2c_lsize);
    int eNum = 0;
    int umv = 549, bits = 212, resolution = 12, zero = 0, crc = 0, firstdata = 0;
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s\n", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    fclose(filehea);

    int delnum=0;
    // Initialize beat detection and classification.
    BDAC bdac;
    bdac.ResetBDAC() ;                                                   //bdac.c
    int lpcount = 0;
    ///useinqrs
    int datahp[1000];
    int datapeak[1000];
    int datade[1000];
    int datadefabs[1000];
    for(int i=0;i<1000;i++){
        datahp[i] = 0;
        datapeak[i] = 0;
        datade[i] = 0;
        datadefabs[i] = 0;
    }
    int dataid=0;

    int qrslen = 1;
    int meanlen = 10;
    int sumlen = 0;
    int qrsmean[10];//存储峰值的数组
    int qrsmeannum[10];//存储峰值位置
    for(int i=0;i<10;i++){
        qrsmean[i] = 0;
        qrsmeannum[i] = 0;
    }
    int meanid=0;//存储峰值数组的id位置
    int sumpeak = 0;//多个峰值和
    int meanpeak = 0;//峰值均值
    annot.time = 0;
    int countann = 0;
    int prenoraml = 0;
    int data[41];//qrs 41points around qrs
    int alasttype = 1;
    int alastrr = 100;
    int nnoraml = 0;
    // Read data from MIT/BIH file until tre is none left.
    while( posd < lengthd)  //local
    {
        if(SampleCount%2==0) {
            dataIN = MAKEWORD(lpc[posd * 3 ], (lpc[posd * 3 + 1 ] & 0x0f));
        }
        else {
            dataIN = MAKEWORD(lpc[posd * 3 + 2], (lpc[posd * 3 + 1] & 0xf0) >> 4);
            posd++;
        }

        if (dataIN & 0x800)
            dataIN |= ~(0xfff); //negative  data, make all the high bit(12 and after) 1
        else dataIN &= 0xfff;        //positive data, make all the hight bit 0
        ++SampleCount ;
        // Pass sample to beat detection and classification.
        delay = bdac.BeatDetectAndClassify(dataIN, &beatType, &beatMatch) ;    //bdac.c
        delay = 45;//36+22;
        //useinqrs
        datahp[dataid] = bdac.qrsdet1.dataqrs[2];
        datapeak[dataid] = bdac.qrsdet1.dataqrs[6];
        datade[dataid] = bdac.qrsdet1.dataqrs[3];
        datadefabs[dataid] = bdac.qrsdet1.dataqrs[4];
        //peak
        if(datapeak[dataid]>0 ){
           if(qrslen<10 && SampleCount > delay)
           {
               sumpeak+=datapeak[dataid];//累积前九个峰值的和
               qrsmean[meanid] = datapeak[dataid];
               qrsmeannum[meanid++] = SampleCount;
           }
           else if (qrslen==10){
               meanpeak = int((sumpeak+datapeak[dataid])*1.0/qrslen+0.5);//计算前十个峰值的均值
               qrsmean[meanid] = datapeak[dataid];
               qrsmeannum[meanid++] = SampleCount;
               if(meanpeak<30)
                   meanpeak = 30;
               sumpeak = 0;
               meanid=0;
               for(int i=0;i<10;i++){
                   if(qrsmean[i]>0.5*meanpeak && qrsmean[i]<2*meanpeak){
                       qrsmean[meanid++]=qrsmean[i]; //把该峰值存入计算峰值均值数组
                       sumpeak += qrsmean[i];        //计算数组内峰值和
                       sumlen++;                     //数组长度
                       beatType = 1;
                       DetectionTime = qrsmeannum[i] - delay ;
                       DetectionTime *= InputFileSampleFrequency ;
                       DetectionTime /= SAMPLE_RATE ;
                       if(annot.time>=DetectionTime){
                           continue;
                       }
                       annot.time = DetectionTime ;
                       annot.anntyp = beatType ;
                       annot.aux = NULL ;
                       annot.width = 10;
                       annot.height = 100;
                       annot.rr = 80;
                       putann2(fileann,&annot,lasttime,0);
                       //WRITE TO THE TMP
                       WRITE_THE_TMP2(annot.anntyp, bdac, m_clusters, m_type, Q_type, S_type,DetectionTime, modeltypen, modeltypev,&delnum);
                   }
               }
               meanpeak = (int)(sumpeak*1.0/sumlen+0.5);
           }
           else{
               countann++;
               if(annotpre.anntyp == 2 )
               {
                   if((SampleCount - delay - annotpre.time)<51)
                       annotpre.anntyp = 15;
                   else if( annotpre.height>0.5*prenoraml && annotpre.height>0.8*annotppre.height)
                       annotpre.anntyp = 1;
                   else
                       annotpre.anntyp = 15;
               }
               if(datapeak[dataid]>0.5*meanpeak && datapeak[dataid]<100){//2*meanpeak){
                   if(meanid>=10){
                       meanid=0;
                   }
                   if(sumlen<10){
                       qrsmean[meanid++]=datapeak[dataid]; //
                       sumpeak += datapeak[dataid];
                       sumlen++;
                       meanpeak = int(sumpeak*1.0/sumlen+0.5);
                   }
                   else if(datapeak[dataid]>0.75*meanpeak && datapeak[dataid]<1.25*meanpeak)
                       {
                       sumpeak += datapeak[dataid] - qrsmean[meanid];
                       meanpeak = int(sumpeak*1.0/meanlen+0.5);
                       qrsmean[meanid++]=datapeak[dataid];
                   }
                   beatType = 1;
                   if(meanpeak>50)
                       meanpeak = 50;
                   else if(meanpeak<10)
                       meanpeak =10;
               }
               else if(datapeak[dataid]>=100){//2*meanpeak){
                   if(datapeak[dataid]>1.5*prenoraml)
                       beatType = 13;
                   else{
                       beatType =1;
                   }
               }
               else{
                   if(countann>2) {
                       if  (SampleCount - delay - annotpre.time < 51)
                           beatType = 15;
                       else{
                           beatType = 2;
                       }
                   }
                   else if(datapeak[dataid]<=0.5*meanpeak)
                       beatType = 15;
                   else
                       beatType = 1;
               }
               DetectionTime = SampleCount - delay ;
               DetectionTime *= InputFileSampleFrequency ;
               DetectionTime /= SAMPLE_RATE ;
               if(annot.time>=DetectionTime){
                   continue;
               }
               //annot.time = DetectionTime ;
               annot.anntyp = beatType;
               //annot.height = datapeak[dataid];
               annot.aux = NULL ;

               int noid=dataid-delay-12;
               if (noid<0)
                   noid +=1000;
               double sumround = 0;
               double sumqrs = 0;
               int mk=0;
               //int data[41];

               for(mk;mk<41;mk++){
                   if(mk<10||mk>30){
                       sumround += datahp[noid]*datahp[noid];
                   }
                   else{
                       sumqrs+=datahp[noid]*datahp[noid];
                   }
                   data[mk] = datahp[noid];
                   noid++;
                   if(noid>=1000)
                       noid=0;
               }

               int maxdn=0,mindn = 1000,maxid = 10,minid =10; //计算中心点左右最大最小值及其位置
               for(int i=20;i>10;i--)
               {
                   if(data[i]>maxdn){
                       maxdn=data[i];
                       maxid = i;
                   }
                   if(data[i]<mindn){
                       mindn = data[i];
                       minid = i;
                   }
               }
               int maxdnr=0,mindnr = 1000,maxidr = 21,minidr =21;
               for(int i=21;i<31;i++)
               {
                   if(data[i]>maxdnr){
                       maxdnr=data[i];
                       maxidr = i;
                   }
                   if(data[i]<mindnr){
                       mindnr = data[i];
                       minidr = i;
                   }
               }
               //int sum = 0;
               mindn = min(mindn,mindnr);
               maxdn = max(maxdn,maxdnr);

               annot.width = minidr-minid;
               annot.height = maxdn-mindn;//
               annot.mode = 0;
               for(int i=minid;i<=minidr;i++){
                   annot.mode += data[i]-mindn;
               }
               if(annot.anntyp == 1){ //根据qrs和周边的能量比，判断qrs是否是噪声

                   sumround = sqrt(sumround*1.0/20.0);
                   sumqrs = sqrt(sumqrs*1.0/21.0)*0.5;

                   if(sumround>sumqrs && minid>11 &&(annot.width<6 || annot.width>20)){
                       annot.anntyp = 13;
                       //printf("%d\n",minid);
                   }
               }
               if(annot.height>1000)
                   annot.anntyp = 13;
               if(annot.time!=0)
                   annot.rr = DetectionTime - annot.time;
               annot.time = DetectionTime;
               //printf("wid:%d, height:%d,rr:%d\n",annot.width,annot.height,annot.rr);
               if(countann>1){
                   if(annotpre.anntyp == 15 ){
                       annot.rr += annotpre.rr;
                       memcpy(&annotpre,&annot,sizeof(annot));
                   }
                   else {
                       if(annotpre.anntyp == 1 ) {
                           if (annotpre.width > annotppre.width && annotppre.anntyp == 1 ) {
                               if(annotpre.width>(annotppre.width+1)){
                                   if(annotpre.height>annotppre.height*1.15)
                                       annotpre.anntyp = 5;
                               }
                               else if(annotpre.height>annotppre.height*1.15 && annotpre.height>annot.height*1.1 && annotpre.width > (annot.width+1) ){
                                   annotpre.anntyp = 5;
                               }
//                               if(annotpre.anntyp == 5){
//                                   FILE* filepvc = fopen("pvc.txt","a+");
//                                   fprintf(filepvc,"detection:%d,height:%d,%d,%d,wid:%d,%d,%d,rr:%d,%d,%d\n",annotpre.time,annotppre.height,annotpre.height,annot.height,annotppre.width,annotpre.width,annot.width,annotppre.rr,annotpre.rr,annot.rr);
//                                   fclose(filepvc);
//                               }
                           }
                           else if (annotpre.rr < 0.80 * annotppre.rr && alasttype == 1 && alastrr<annotppre.rr*1.05 && alastrr>annotppre.rr*0.95 & annotpre.height<annotppre.height*1.1 && annotpre.height>annotppre.height*0.9)//&& (annotpre.width < (annotppre.width+1)) && (annotpre.width > (annotppre.width-1)) && annotppre.anntyp==1) {
                           {
                               if(annotpre.rr <= 0.9* annot.rr )//&& (annotppre.rr - annotpre.rr)>0.1*128&& annotpre.rr >0.90 * annot.rr
                                   annotpre.anntyp = 9;
                               else if (annotpre.rr > 0.9 * annot.rr && annotpre.rr < 1.1 * annot.rr) {
                                   annotpre.anntyp = 9;
                               }
//                               if(annotpre.anntyp == 9)
//                                   printf("detection:%d,height:%d,%d,%d,wid:%d,%d,%d,rr:%d,%d,%d\n",annotpre.time,annotppre.height,annotpre.height,annot.height,annotppre.width,annotpre.width,annot.width,annotppre.rr,annotpre.rr,annot.rr);


                           }
                           else if(annotppre.anntyp==5){
                               if(annotppre.rr>0.9*annotpre.rr && annotppre.rr<1.1*annotpre.rr  && annotpre.height<annotppre.height*1.05 && annotpre.height>annotppre.height*0.95)
                               {
                                   if((annotpre.width < (annotppre.width+1)) && (annotpre.width>(annotppre.width-1)))
                                       annotpre.anntyp = 5;
                               }

                           }
                           else if(annotppre.anntyp==9){
                               if(annotppre.rr>0.95*annotpre.rr && annotppre.rr<1.05*annotpre.rr && annotpre.height<annotppre.height*1.1 && annotpre.height>annotppre.height*0.9)
                               {
                                   if(alasttype == 1 && annotpre.rr < 0.80 * alastrr)
                                       annotpre.anntyp = 9;
                                   else if(alasttype==9){
                                       annotpre.anntyp = 9;
                                   }
//                                   if(annotpre.anntyp == 9)
//                                   printf("detection:%d,height:%d,%d,%d,wid:%d,%d,%d,rr:%d,%d,%d\n",annotpre.time,annotppre.height,annotpre.height,annot.height,annotppre.width,annotpre.width,annot.width,annotppre.rr,annotpre.rr,annot.rr);

                               }

                           }

                       }
                       if(annotpre.mode>annotppre.mode*1.7 && annotpre.height<1000 && annotpre.mode<10000 && annotpre.mode>1000 && annotpre.width>5 && annotpre.width>annotppre.width && annotppre.anntyp!=13){
                           annotpre.anntyp = 5;
                       }
                       if(annotpre.anntyp==1 && annotppre.anntyp == 1 && annotpre.height<annotppre.height*0.2){ //排除分类为normal的小噪声
                           annot.rr += annotpre.rr;
                           memcpy(&annotpre,&annot,sizeof(annot));
                       }
                       else{
                           putann2(fileann, &annotpre, lasttime, 0);
                           //WRITE TO THE TMP
                           WRITE_THE_TMP3(annotpre.anntyp, m_type, Q_type, S_type, V_type, annotpre.time);
                           alasttype = annotppre.anntyp;
                           alastrr = annotppre.rr;
                           memcpy(&annotppre, &annotpre, sizeof(annotpre));
                           memcpy(&annotpre, &annot, sizeof(annot));
                           if (annotppre.anntyp == 1)
                               prenoraml = annotppre.height;
                       }
                   }
               }
               else //(countann==1){
                   memcpy(&annotpre,&annot,sizeof(annot));

           }
            qrslen++;
        }


        //useinqrs
        dataid++;
        if(dataid>=1000)
            dataid=0;
        // printf("%d\n",SampleCount);
        // save the real-data
        OUTlpc[lpcount] =bdac.qrsdet1.datafilt;
        INlpc[lpcount++] = dataIN;
    }

//
    //2 int change to 3 chars
    int dif = LPBUFFER_LGTH/2-1+(HPBUFFER_LGTH-1)/2;
    for(int i=0;i<lengthd*2;i++)
    {
        int id = i+dif;
        if(id>=lengthd*2){
            id=lengthd*2-1;
        }
        lpc2[0] = LOBYTE((short) INlpc[i]);
        lpc2[1] = 0;
        lpc2[1] = HIBYTE((short) INlpc[i]) & 0x0f;
        lpc2[2] = LOBYTE((short) OUTlpc[id]);
        lpc2[1] |= HIBYTE((short) OUTlpc[id]) << 4;
        lpc2 += 3;
    }
    fwrite( buf, sizeof(char), file2c_lsize, fp);
    fclose(fp);//close the 2-channal-dat file
    delete[]buf;
    delete[]lpc;
    delete[]INlpc;
    delete[]OUTlpc;

    wfdb_p16(0, fileann);//STOP WRITE THE ATEST FILE
    fclose(fileann);//CLOSE WRITE THE annotion FILE
    fclose(filed); //CLOSE THE 1-channal-DAT FILE

    // Write the new address book back to disk.
    int Nnum = 0, Vnum=0, Anum = 0;
    int countN = 0,countV = 0,countA=0,countS=0;
    bool Nfind1 = false, Vfind1 = false, Afind1 = false;
    int Nfind1ID = 0, Vfind1ID = 0, Afind1ID = 0;
    fstream tempfile(ecg_tmp_file_path, ios::out | ios::trunc | ios::binary);
    Template1 *tmp1N = tmpN->add_template1s();
    tmp1N->set_id(0);
    Template1 *tmp1V = tmpV->add_template1s();
    tmp1V->set_id(0);
    Template1 *tmp1A = tmpA->add_template1s();
    tmp1A->set_id(0);
    Template1 *tmp1S = tmpS->add_template1s();
    tmp1S->set_id(0);

    if (Q_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1A->add_template2s();
        tmp1->set_id(0);
        countA += Q_type.size();
        for (int k = 0; k < Q_type.size(); k++) {
            tmp1->add_positions_of_beats(Q_type[k]);
        }
    }
    if (V_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1V->add_template2s();
        tmp1->set_id(0);
        countV += V_type.size();
        for (int k = 0; k < V_type.size(); k++) {
            tmp1->add_positions_of_beats(V_type[k]);
        }
    }
    if (S_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1S->add_template2s();
        tmp1->set_id(0);
        countS += S_type.size();
        for (int k = 0; k < S_type.size(); k++) {
            tmp1->add_positions_of_beats(S_type[k]);
        }
    }
    if (m_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1N->add_template2s();
        tmp1->set_id(0);
        countN += m_type.size();
        for (int k = 0; k < m_type.size(); k++) {
            tmp1->add_positions_of_beats(m_type[k]);
        }
    }

    //printf("all tmp = %d\n", Anum + Vnum +Nnum);
    printf("normal = %d\n",m_type.size());
    printf("PVC = %d\n",V_type.size());
    printf("Q = %d\n",Q_type.size());
    printf("S = %d\n",S_type.size());
    if (!tmp.SerializeToOstream(&tempfile)) {
        cerr << "Failed to write address book." << endl;
        return -1;
    }
    google::protobuf::ShutdownProtobufLibrary();
//
    return 0;
}

void checkqrs(int* data, int* dd, int* deabs,data_qrs* qrs){
    qrs->maxd = 0;
    qrs->mind = 500;
    int k=0;
    for(k=26;k<46;k++){
        if(data[k]>qrs->maxd){
            qrs->maxd = data[k];
            qrs->maxid = k;
        }
        if(data[k]<qrs->mind){
            qrs->mind = data[k];
            qrs->minid=k;
        }
    }
    int l = 0;
    int r = 0;
    for(k=qrs->maxid+2;k<qrs->maxid+22;k++){
        if(dd[k]*dd[k+1]<=0 && dd[k-1]*dd[k+2]<=0){
            r=k;
            k=qrs->maxid+22;
        }
    }
    for(k=qrs->maxid-2;k>qrs->maxid-22;k--){
        if(dd[k]*dd[k+1]<=0 && dd[k-1]*dd[k+2]<=0){
            l=k;
            k=qrs->maxid-22;
        }
    }
    qrs->demax = 0;
    for(k=16;k<56;k++)
    {
        if(deabs[k]>qrs->demax)
            qrs->demax = deabs[k];
    }
    if(l==0||r==0)
        qrs->wid = 0;
    else
        qrs->wid = r-l;

}

void TESTRECORD::WRITE_THE_TMP3(int beatType,std::vector<int>& m_type,std::vector<int>& Q_type,std::vector<int>& S_type,std::vector<int>& V_type, long DetectionTime){
    //WRITE THE TMP
    int DetectionT = (int)DetectionTime;
    //int morphTypenew = bdac.match1.morphType;
    if(beatType == 13){//Q
        Q_type.push_back(DetectionT);
    }
    else if(beatType == 9) {
        S_type.push_back(DetectionT);
    }
    else if(beatType == 1){
        m_type.push_back(DetectionT);
    }
    else if(beatType == 5){
        V_type.push_back(DetectionT);
    }
}

void TESTRECORD::WRITE_THE_TMP2(int beatType,BDAC bdac,std::vector< std::vector<int> >& m_clusters,std::vector<int>& m_type,std::vector<int>& Q_type,std::vector<int>& S_type,
                                long DetectionTime,int* modeltypen,int* modeltypev,int* delnum)
{
     //WRITE THE TMP
    int DetectionT = (int)DetectionTime;
    //int morphTypenew = bdac.match1.morphType;
    if(beatType == 13){//Q
        Q_type.push_back(DetectionT);
    }
    else if(beatType == 9) {
        S_type.push_back(DetectionT);
    }
    else if(beatType == 1){
        m_type.push_back(DetectionT);
    }


}

//easy1

/*easy1
int TESTRECORD::TestRecord_qrs(const char *data_file_path)
{
    char *data_file_name;
    char date_tmp[_MAX_PATH]; //XXX/201414/
    char ecg_file_name[_MAX_PATH];
    char date_path[_MAX_PATH];
    char ecg_filtered_data_file_path[_MAX_PATH]; //saved file name
    char ecg_annotation_file_path[_MAX_PATH]; //saved file name
    char ecg_head_file_path[_MAX_PATH]; //saved file name           7
    char ecg_tmp_file_path[_MAX_PATH]; //saved file name           7
    char ecg_config_file_path[_MAX_PATH];// the path with config
    //get the read 1-channal-dat and write 2-channal-dat path
    string WRITE_PATH,READ_PATH;
    conf::Instance()->Load(SYS_CONF);
    conf::Instance()->Get("write_path", WRITE_PATH);
    conf::Instance()->Get("read_path", READ_PATH);
    //get the filename and the last foldername
    memset(date_tmp, 0, _MAX_PATH);
    data_file_name = get_file_name(data_file_path);
    strncpy(ecg_file_name, data_file_name,_MAX_PATH);
    remove_extension(ecg_file_name);
    strncpy(date_tmp, data_file_path, strlen(data_file_path) - strlen(data_file_name) - 1);
    strncpy(date_path, get_file_name(date_tmp),_MAX_PATH);
    //get the full file path
    snprintf(ecg_filtered_data_file_path,_MAX_PATH, "%s/%s/%s.dat", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_annotation_file_path,_MAX_PATH, "%s/%s/%s.bsp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_head_file_path,_MAX_PATH, "%s/%s/%s.hea", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_tmp_file_path,_MAX_PATH, "%s/%s/%s.tmp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_config_file_path,_MAX_PATH, "%s/%s/%s.cnf", READ_PATH.c_str(), date_path, ecg_file_name);
    //variable initial
    Initial();
    //use the google_protobuf
    GOOGLE_PROTOBUF_VERIFY_VERSION;
    //Template tmp;
    temp::BeatTemplate *tmpN=tmp.add_beat_templates();
    temp::BeatTemplate *tmpA=tmp.add_beat_templates();
    temp::BeatTemplate *tmpV=tmp.add_beat_templates();
    temp::BeatTemplate *tmpS=tmp.add_beat_templates();
    tmpA->set_type(BeatTemplate::A);
    tmpN->set_type(BeatTemplate::N);
    tmpV->set_type(BeatTemplate::V);
    tmpS->set_type(BeatTemplate::S);
    //using in tmp
    int modeltypev[MAXTYPES+1];
    int modeltypen[MAXTYPES+1];
    for(int i=0;i<MAXTYPES+1;i++)
    {
        modeltypev[i] = 0;
        modeltypen[i] = 0;
    }
    std::vector< std::vector<int> > m_clusters;
    std::vector<int> m_type;
    std::vector<int> Q_type;
    std::vector<int> S_type;
    //write to annot
    WFDB_Annotation annot ;
    FILE *fileann = fopen(ecg_annotation_file_path,"wb");//

    //find QRS
    int delay;
    int InputFileSampleFrequency = 128;
    long SampleCount = 0;
    long DetectionTime = 0;
    int beatType, beatMatch ;
    lasttime =0;


    // Open a 1 channel record
    FILE* filed = fopen(data_file_path,"r");//
    if(!filed){
        printf("please check the file:%s!",data_file_path);
        return 0;
    }
    fseek(filed,0,2);
    long flend=ftell(filed); // 得到文件大小
    int lengthd = flend/3;
    int posd=0;              // read the 1-channal-locate, once by 3 chars
    char* lpc = new char[flend]; //read
    int* INlpc = new int[lengthd*2];//the real data in 1-channal-file
    int* OUTlpc = new int[lengthd*2];//the real data in 2-channal-file
    fseek(filed, 0, SEEK_SET);
    fread(lpc, flend,1,filed);
    int dataIN;

    //write to the 2-channal-dat file
    int file2c_lsize = flend*2;
    FILE* fp = fopen(ecg_filtered_data_file_path,"w");
    if (fp == NULL){
        printf("can't open the output 2-channel file!");
        return 0;
    }
    char *buf = new char[file2c_lsize];//(char *) malloc(file2c_lsize);
    char* lpc2 = (char *) buf;

    //write the head file
    FILE *filehea = fopen(ecg_head_file_path, "w");
    int sNum = 2;
    float sr = 128;
    int res = fprintf(filehea, "%s %d %3.0f %d\n", ecg_file_name, sNum, sr, file2c_lsize);
    int eNum = 0;
    int umv = 549, bits = 212, resolution = 12, zero = 0, crc = 0, firstdata = 0;
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s\n", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    fclose(filehea);

    int delnum=0;
    // Initialize beat detection and classification.
    BDAC bdac;
    bdac.ResetBDAC() ;                                                   //bdac.c
    int lpcount = 0;
    ///useinqrs
    int datahp[1000];
    int datapeak[1000];
    int datade[1000];
    int datadefabs[1000];
    for(int i=0;i<1000;i++){
        datahp[i] = 0;
        datapeak[i] = 0;
        datade[i] = 0;
        datadefabs[i] = 0;
    }
    int dataid=0;
    int qrsdata[72];
    int qrsde[72];
    int qrsfabs[72];
    data_qrs qrs_data;
    int qrslen = 1;
    int meanlen = 10;
    int sumlen = 0;
    int qrsmean[10];//存储峰值的数组
    int qrsmeannum[10];//存储峰值位置
    int meanid=0;//存储峰值数组的id位置
    int sumpeak = 0;//多个峰值和
    int meanpeak = 0;//峰值均值
    delay = 36+22;
    annot.time = 0;
    // Read data from MIT/BIH file until tre is none left.
    while( posd < lengthd)  //local
    {
        if(SampleCount%2==0) {
            dataIN = MAKEWORD(lpc[posd * 3 ], (lpc[posd * 3 + 1 ] & 0x0f));
        }
        else {
            dataIN = MAKEWORD(lpc[posd * 3 + 2], (lpc[posd * 3 + 1] & 0xf0) >> 4);
            posd++;
        }

        if (dataIN & 0x800)
            dataIN |= ~(0xfff); //negative  data, make all the high bit(12 and after) 1
        else dataIN &= 0xfff;        //positive data, make all the hight bit 0
        ++SampleCount ;
        // Pass sample to beat detection and classification.
        delay = bdac.BeatDetectAndClassify(dataIN, &beatType, &beatMatch) ;    //bdac.c
        delay = 45;//36+22;
        //useinqrs
        datahp[dataid] = bdac.qrsdet1.dataqrs[2];
        datapeak[dataid] = bdac.qrsdet1.dataqrs[6];
        datade[dataid] = bdac.qrsdet1.dataqrs[3];
        datadefabs[dataid] = bdac.qrsdet1.dataqrs[4];
        //peak
        if(datapeak[dataid]>0 ){
           if(qrslen<10 && SampleCount > delay)
           {
               sumpeak+=datapeak[dataid];//累积前九个峰值的和
               qrsmean[meanid] = datapeak[dataid];
               qrsmeannum[meanid++] = SampleCount;
           }
           else if (qrslen==10){
               meanpeak = int((sumpeak+datapeak[dataid])*1.0/qrslen+0.5);//计算前十个峰值的均值
               qrsmean[meanid] = datapeak[dataid];
               qrsmeannum[meanid++] = SampleCount;
               if(meanpeak<30)
                   meanpeak = 30;
               sumpeak = 0;
               meanid=0;
               for(int i=0;i<10;i++){
                   if(qrsmean[i]>0.5*meanpeak && qrsmean[i]<2*meanpeak){
                       qrsmean[meanid++]=qrsmean[i]; //把该峰值存入计算峰值均值数组
                       sumpeak += qrsmean[i];        //计算数组内峰值和
                       sumlen++;                     //数组长度
                       DetectionTime = qrsmeannum[i] - delay ;
                       DetectionTime *= InputFileSampleFrequency ;
                       DetectionTime /= SAMPLE_RATE ;
                       if(annot.time>=DetectionTime){
                           continue;
                       }
                       annot.time = DetectionTime ;
                       annot.anntyp = 1 ;
                       annot.aux = NULL ;
                       putann2(fileann,&annot,lasttime,0);
                       //WRITE TO THE TMP
                       //WRITE_THE_TMP(beatType, bdac, m_clusters, m_type, Q_type, DetectionTime, modeltypen, modeltypev,&delnum);
                       WRITE_THE_TMP2(annot.anntyp, bdac, m_clusters, m_type, Q_type, S_type,DetectionTime, modeltypen, modeltypev,&delnum);
                   }
               }
               meanpeak = (int)(sumpeak*1.0/sumlen+0.5);
           }
           else{
               if(datapeak[dataid]>0.5*meanpeak && datapeak[dataid]<100){//2*meanpeak){
                   if(meanid>=10){
                       meanid=0;
                   }
                   if(sumlen<10){
                       qrsmean[meanid++]=datapeak[dataid]; //
                       sumpeak += datapeak[dataid];
                       sumlen++;
                       meanpeak = int(sumpeak*1.0/sumlen+0.5);
                   }
                   else //if(datapeak[dataid]>0.5*meanpeak && datapeak[dataid]<2*meanpeak)
                       {
                       sumpeak += datapeak[dataid] - qrsmean[meanid];
                       meanpeak = int(sumpeak*1.0/meanlen+0.5);
                       qrsmean[meanid++]=datapeak[dataid];
                   }
                   beatType = 1;
                   if(meanpeak>50)
                       meanpeak = 50;
                   else if(meanpeak<10)
                       meanpeak =10;
               }
               else if(datapeak[dataid]>=100){//2*meanpeak){
                   beatType = 13;
               }
               else{
                   beatType = 9;
               }
               DetectionTime = SampleCount - delay ;
               DetectionTime *= InputFileSampleFrequency ;
               DetectionTime /= SAMPLE_RATE ;
               if(annot.time>=DetectionTime){
                   continue;
               }
               annot.time = DetectionTime ;
               annot.anntyp = beatType;
               annot.aux = NULL ;
               putann2(fileann,&annot,lasttime,0);
               //WRITE TO THE TMP
               //WRITE_THE_TMP(beatType, bdac, m_clusters, m_type, Q_type, DetectionTime, modeltypen, modeltypev,&delnum);
               WRITE_THE_TMP2(annot.anntyp, bdac, m_clusters, m_type, Q_type, S_type,DetectionTime, modeltypen, modeltypev,&delnum);
           }
            qrslen++;
        }


        //useinqrs
        dataid++;
        if(dataid>=1000)
            dataid=0;
        // printf("%d\n",SampleCount);
        // save the real-data
        OUTlpc[lpcount] =bdac.qrsdet1.datafilt;
        INlpc[lpcount++] = dataIN;
    }


    //2 int change to 3 chars
    int dif = LPBUFFER_LGTH/2-1+(HPBUFFER_LGTH-1)/2;
    for(int i=0;i<lengthd*2;i++)
    {
        int id = i+dif;
        if(id>=lengthd*2){
            id=lengthd*2-1;
        }
        lpc2[0] = LOBYTE((short) INlpc[i]);
        lpc2[1] = 0;
        lpc2[1] = HIBYTE((short) INlpc[i]) & 0x0f;
        lpc2[2] = LOBYTE((short) OUTlpc[id]);
        lpc2[1] |= HIBYTE((short) OUTlpc[id]) << 4;
        lpc2 += 3;
    }
    fwrite( buf, sizeof(char), file2c_lsize, fp);
    fclose(fp);//close the 2-channal-dat file
    delete[]buf;
    delete[]lpc;
    delete[]INlpc;
    delete[]OUTlpc;
    //
    //printf("Record:%s,%d,%d\n",data_file_name,m_type.size(),delnum);
    wfdb_p16(0, fileann);//STOP WRITE THE ATEST FILE
    fclose(fileann);//CLOSE WRITE THE annotion FILE
    fclose(filed); //CLOSE THE 1-channal-DAT FILE

    // Write the new address book back to disk.
    int Nnum = 0, Vnum=0, Anum = 0;
    int countN = 0,countV = 0,countA=0,countS=0;
    bool Nfind1 = false, Vfind1 = false, Afind1 = false;
    int Nfind1ID = 0, Vfind1ID = 0, Afind1ID = 0;
    fstream tempfile(ecg_tmp_file_path, ios::out | ios::trunc | ios::binary);
    Template1 *tmp1N = tmpN->add_template1s();
    tmp1N->set_id(0);
    Template1 *tmp1V = tmpV->add_template1s();
    tmp1V->set_id(0);
    Template1 *tmp1A = tmpA->add_template1s();
    tmp1A->set_id(0);
    Template1 *tmp1S = tmpS->add_template1s();
    tmp1S->set_id(0);

    if (Q_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1A->add_template2s();
        tmp1->set_id(0);
        countA += Q_type.size();
        for (int k = 0; k < Q_type.size(); k++) {
            tmp1->add_positions_of_beats(Q_type[k]);
        }
    }
    if (S_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1S->add_template2s();
        tmp1->set_id(0);
        countS += S_type.size();
        for (int k = 0; k < S_type.size(); k++) {
            tmp1->add_positions_of_beats(S_type[k]);
        }
    }
    if (m_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1N->add_template2s();
        tmp1->set_id(0);
        countN += m_type.size();
        for (int k = 0; k < m_type.size(); k++) {
            tmp1->add_positions_of_beats(m_type[k]);
        }
    }
printf("all tmp = %d\n", Anum + Vnum +Nnum);
if (!tmp.SerializeToOstream(&tempfile)) {
cerr << "Failed to write address book." << endl;
return -1;
}
google::protobuf::ShutdownProtobufLibrary();

return 0;
}
 */

//easy2o

/*
int TESTRECORD::TestRecord_qrs(const char *data_file_path)
{
    char *data_file_name;
    char date_tmp[_MAX_PATH]; //XXX/201414/
    char ecg_file_name[_MAX_PATH];
    char date_path[_MAX_PATH];
    char ecg_filtered_data_file_path[_MAX_PATH]; //saved file name
    char ecg_annotation_file_path[_MAX_PATH]; //saved file name
    char ecg_head_file_path[_MAX_PATH]; //saved file name           7
    char ecg_tmp_file_path[_MAX_PATH]; //saved file name           7
    char ecg_config_file_path[_MAX_PATH];// the path with config
    //get the read 1-channal-dat and write 2-channal-dat path
    string WRITE_PATH,READ_PATH;
    conf::Instance()->Load(SYS_CONF);
    conf::Instance()->Get("write_path", WRITE_PATH);
    conf::Instance()->Get("read_path", READ_PATH);
    //get the filename and the last foldername
    memset(date_tmp, 0, _MAX_PATH);
    data_file_name = get_file_name(data_file_path);
    strncpy(ecg_file_name, data_file_name,_MAX_PATH);
    remove_extension(ecg_file_name);
    strncpy(date_tmp, data_file_path, strlen(data_file_path) - strlen(data_file_name) - 1);
    strncpy(date_path, get_file_name(date_tmp),_MAX_PATH);
    //get the full file path
    snprintf(ecg_filtered_data_file_path,_MAX_PATH, "%s/%s/%s.dat", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_annotation_file_path,_MAX_PATH, "%s/%s/%s.bsp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_head_file_path,_MAX_PATH, "%s/%s/%s.hea", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_tmp_file_path,_MAX_PATH, "%s/%s/%s.tmp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_config_file_path,_MAX_PATH, "%s/%s/%s.cnf", READ_PATH.c_str(), date_path, ecg_file_name);
    //variable initial
    Initial();
    //use the google_protobuf
    GOOGLE_PROTOBUF_VERIFY_VERSION;
    //Template tmp;
    temp::BeatTemplate *tmpN=tmp.add_beat_templates();
    temp::BeatTemplate *tmpA=tmp.add_beat_templates();
    temp::BeatTemplate *tmpV=tmp.add_beat_templates();
    temp::BeatTemplate *tmpS=tmp.add_beat_templates();
    tmpA->set_type(BeatTemplate::A);
    tmpN->set_type(BeatTemplate::N);
    tmpV->set_type(BeatTemplate::V);
    tmpS->set_type(BeatTemplate::S);
    //using in tmp
    int modeltypev[MAXTYPES+1];
    int modeltypen[MAXTYPES+1];
    for(int i=0;i<MAXTYPES+1;i++)
    {
        modeltypev[i] = 0;
        modeltypen[i] = 0;
    }
    std::vector< std::vector<int> > m_clusters;
    std::vector<int> m_type;
    std::vector<int> Q_type;
    std::vector<int> S_type;
    //write to annot
    WFDB_Annotation annotppre ;
    WFDB_Annotation annotpre ;
    WFDB_Annotation annot ;
    FILE *fileann = fopen(ecg_annotation_file_path,"wb");//

    //find QRS
    int delay;
    int InputFileSampleFrequency = 128;
    long SampleCount = 0;
    long DetectionTime = 0;
    int beatType, beatMatch ;
    lasttime =0;


    // Open a 1 channel record
    FILE* filed = fopen(data_file_path,"r");//
    if(!filed){
        printf("please check the file:%s!",data_file_path);
        return 0;
    }
    fseek(filed,0,2);
    long flend=ftell(filed); // 得到文件大小
    int lengthd = flend/3;
    int posd=0;              // read the 1-channal-locate, once by 3 chars
    char* lpc = new char[flend]; //read
    int* INlpc = new int[lengthd*2];//the real data in 1-channal-file
    int* OUTlpc = new int[lengthd*2];//the real data in 2-channal-file
    fseek(filed, 0, SEEK_SET);
    fread(lpc, flend,1,filed);
    int dataIN;

    //write to the 2-channal-dat file
    int file2c_lsize = flend*2;
    FILE* fp = fopen(ecg_filtered_data_file_path,"w");
    if (fp == NULL){
        printf("can't open the output 2-channel file!");
        return 0;
    }
    char *buf = new char[file2c_lsize];//(char *) malloc(file2c_lsize);
    char* lpc2 = (char *) buf;

    //write the head file
    FILE *filehea = fopen(ecg_head_file_path, "w");
    int sNum = 2;
    float sr = 128;
    int res = fprintf(filehea, "%s %d %3.0f %d\n", ecg_file_name, sNum, sr, file2c_lsize);
    int eNum = 0;
    int umv = 549, bits = 212, resolution = 12, zero = 0, crc = 0, firstdata = 0;
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s\n", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    fclose(filehea);

    int delnum=0;
    // Initialize beat detection and classification.
    BDAC bdac;
    bdac.ResetBDAC() ;                                                   //bdac.c
    int lpcount = 0;
    ///useinqrs
    int datahp[1000];
    int datapeak[1000];
    int datade[1000];
    int datadefabs[1000];
    for(int i=0;i<1000;i++){
        datahp[i] = 0;
        datapeak[i] = 0;
        datade[i] = 0;
        datadefabs[i] = 0;
    }
    int dataid=0;
    int qrsdata[72];
    int qrsde[72];
    int qrsfabs[72];
    data_qrs qrs_data;
    int qrslen = 1;
    int meanlen = 10;
    int sumlen = 0;
    int qrsmean[10];//存储峰值的数组
    int qrsmeannum[10];//存储峰值位置
    int meanid=0;//存储峰值数组的id位置
    int sumpeak = 0;//多个峰值和
    int meanpeak = 0;//峰值均值
    delay = 36+22;
    annot.time = 0;
    int countann = 0;
    // Read data from MIT/BIH file until tre is none left.
    while( posd < lengthd)  //local
    {
        if(SampleCount%2==0) {
            dataIN = MAKEWORD(lpc[posd * 3 ], (lpc[posd * 3 + 1 ] & 0x0f));
        }
        else {
            dataIN = MAKEWORD(lpc[posd * 3 + 2], (lpc[posd * 3 + 1] & 0xf0) >> 4);
            posd++;
        }

        if (dataIN & 0x800)
            dataIN |= ~(0xfff); //negative  data, make all the high bit(12 and after) 1
        else dataIN &= 0xfff;        //positive data, make all the hight bit 0
        ++SampleCount ;
        // Pass sample to beat detection and classification.
        delay = bdac.BeatDetectAndClassify(dataIN, &beatType, &beatMatch) ;    //bdac.c
        delay = 45;//36+22;
        //useinqrs
        datahp[dataid] = bdac.qrsdet1.dataqrs[2];
        datapeak[dataid] = bdac.qrsdet1.dataqrs[6];
        datade[dataid] = bdac.qrsdet1.dataqrs[3];
        datadefabs[dataid] = bdac.qrsdet1.dataqrs[4];
        //peak
        if(datapeak[dataid]>0 ){
            if(qrslen<10 && SampleCount > delay)
            {
                sumpeak+=datapeak[dataid];//累积前九个峰值的和
                qrsmean[meanid] = datapeak[dataid];
                qrsmeannum[meanid++] = SampleCount;
            }
            else if (qrslen==10){
                meanpeak = int((sumpeak+datapeak[dataid])*1.0/qrslen+0.5);//计算前十个峰值的均值
                qrsmean[meanid] = datapeak[dataid];
                qrsmeannum[meanid++] = SampleCount;
                if(meanpeak<30)
                    meanpeak = 30;
                sumpeak = 0;
                meanid=0;
                for(int i=0;i<10;i++){
                    if(qrsmean[i]>0.5*meanpeak && qrsmean[i]<2*meanpeak){
                        qrsmean[meanid++]=qrsmean[i]; //把该峰值存入计算峰值均值数组
                        sumpeak += qrsmean[i];        //计算数组内峰值和
                        sumlen++;                     //数组长度
                        DetectionTime = qrsmeannum[i] - delay ;
                        DetectionTime *= InputFileSampleFrequency ;
                        DetectionTime /= SAMPLE_RATE ;
                        if(annot.time>=DetectionTime){
                            continue;
                        }
                        annot.time = DetectionTime ;
                        annot.anntyp = 1 ;
                        annot.aux = NULL ;
                        putann2(fileann,&annot,lasttime,0);
                        //WRITE TO THE TMP
                        WRITE_THE_TMP2(annot.anntyp, bdac, m_clusters, m_type, Q_type, S_type,DetectionTime, modeltypen, modeltypev,&delnum);
                    }
                }
                meanpeak = (int)(sumpeak*1.0/sumlen+0.5);
            }
            else{
                countann++;
                if(annotpre.anntyp == 2 && (SampleCount - delay - annotpre.time)<51)
                {
                    annotpre.anntyp = 9;
                }
                else if(annotpre.anntyp == 2){
                    annotpre.anntyp = 1;
                }
                if(datapeak[dataid]>0.5*meanpeak && datapeak[dataid]<100){//2*meanpeak){
                    if(meanid>=10){
                        meanid=0;
                    }
                    if(sumlen<10){
                        qrsmean[meanid++]=datapeak[dataid]; //
                        sumpeak += datapeak[dataid];
                        sumlen++;
                        meanpeak = int(sumpeak*1.0/sumlen+0.5);
                    }
                    else if(datapeak[dataid]>0.75*meanpeak && datapeak[dataid]<1.25*meanpeak)
                    {
                        sumpeak += datapeak[dataid] - qrsmean[meanid];
                        meanpeak = int(sumpeak*1.0/meanlen+0.5);
                        qrsmean[meanid++]=datapeak[dataid];
                    }
                    beatType = 1;
                    if(meanpeak>50)
                        meanpeak = 50;
                    else if(meanpeak<10)
                        meanpeak =10;
                }
                else if(datapeak[dataid]>=100){//2*meanpeak){
                    beatType = 13;
                }
                else{
                    if(countann>2) {
                        if  (SampleCount - delay - annotpre.time < 51)
                            beatType = 9;
                        else {
                            beatType = 2;
                        }
                    }
                }
                DetectionTime = SampleCount - delay ;
                DetectionTime *= InputFileSampleFrequency ;
                DetectionTime /= SAMPLE_RATE ;
                if(annot.time>=DetectionTime){
                    continue;
                }
                annot.time = DetectionTime ;
                annot.anntyp = beatType;
                annot.aux = NULL ;


                if(countann>1){
                    putann2(fileann,&annotpre,lasttime,0);
                    //WRITE TO THE TMP
                    //WRITE_THE_TMP2(annotpre.anntyp, bdac, m_clusters, m_type, Q_type, S_type,DetectionTime, modeltypen, modeltypev,&delnum);
                    WRITE_THE_TMP2(annotpre.anntyp, bdac, m_clusters, m_type, Q_type, S_type,annotpre.time, modeltypen, modeltypev,&delnum);
                }
                if(countann==1){
                    memcpy(&annotpre,&annot,sizeof(annot));
                }
                else{
                    memcpy(&annotppre,&annotpre,sizeof(annotpre));
                    memcpy(&annotpre,&annot,sizeof(annot));
                }
            }
            qrslen++;
        }


        //useinqrs
        dataid++;
        if(dataid>=1000)
            dataid=0;
        // printf("%d\n",SampleCount);
        // save the real-data
        OUTlpc[lpcount] =bdac.qrsdet1.datafilt;
        INlpc[lpcount++] = dataIN;
    }


    //2 int change to 3 chars
    int dif = LPBUFFER_LGTH/2-1+(HPBUFFER_LGTH-1)/2;
    for(int i=0;i<lengthd*2;i++)
    {
        int id = i+dif;
        if(id>=lengthd*2){
            id=lengthd*2-1;
        }
        lpc2[0] = LOBYTE((short) INlpc[i]);
        lpc2[1] = 0;
        lpc2[1] = HIBYTE((short) INlpc[i]) & 0x0f;
        lpc2[2] = LOBYTE((short) OUTlpc[id]);
        lpc2[1] |= HIBYTE((short) OUTlpc[id]) << 4;
        lpc2 += 3;
    }
    fwrite( buf, sizeof(char), file2c_lsize, fp);
    fclose(fp);//close the 2-channal-dat file
    delete[]buf;
    delete[]lpc;
    delete[]INlpc;
    delete[]OUTlpc;

    wfdb_p16(0, fileann);//STOP WRITE THE ATEST FILE
    fclose(fileann);//CLOSE WRITE THE annotion FILE
    fclose(filed); //CLOSE THE 1-channal-DAT FILE

    // Write the new address book back to disk.
    int Nnum = 0, Vnum=0, Anum = 0;
    int countN = 0,countV = 0,countA=0,countS=0;
    bool Nfind1 = false, Vfind1 = false, Afind1 = false;
    int Nfind1ID = 0, Vfind1ID = 0, Afind1ID = 0;
    fstream tempfile(ecg_tmp_file_path, ios::out | ios::trunc | ios::binary);
    Template1 *tmp1N = tmpN->add_template1s();
    tmp1N->set_id(0);
    Template1 *tmp1V = tmpV->add_template1s();
    tmp1V->set_id(0);
    Template1 *tmp1A = tmpA->add_template1s();
    tmp1A->set_id(0);
    Template1 *tmp1S = tmpS->add_template1s();
    tmp1S->set_id(0);

    if (Q_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1A->add_template2s();
        tmp1->set_id(0);
        countA += Q_type.size();
        for (int k = 0; k < Q_type.size(); k++) {
            tmp1->add_positions_of_beats(Q_type[k]);
        }
    }
    if (S_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1S->add_template2s();
        tmp1->set_id(0);
        countS += S_type.size();
        for (int k = 0; k < S_type.size(); k++) {
            tmp1->add_positions_of_beats(S_type[k]);
        }
    }
    if (m_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1N->add_template2s();
        tmp1->set_id(0);
        countN += m_type.size();
        for (int k = 0; k < m_type.size(); k++) {
            tmp1->add_positions_of_beats(m_type[k]);
        }
    }

    printf("all tmp = %d\n", Anum + Vnum +Nnum);
    if (!tmp.SerializeToOstream(&tempfile)) {
        cerr << "Failed to write address book." << endl;
        return -1;
    }
    google::protobuf::ShutdownProtobufLibrary();

    return 0;
}
*/

//easy2

/*
int TESTRECORD::TestRecord_qrs(const char *data_file_path)
{
    char *data_file_name;
    char date_tmp[_MAX_PATH]; //XXX/201414/
    char ecg_file_name[_MAX_PATH];
    char date_path[_MAX_PATH];
    char ecg_filtered_data_file_path[_MAX_PATH]; //saved file name
    char ecg_annotation_file_path[_MAX_PATH]; //saved file name
    char ecg_head_file_path[_MAX_PATH]; //saved file name           7
    char ecg_tmp_file_path[_MAX_PATH]; //saved file name           7
    char ecg_config_file_path[_MAX_PATH];// the path with config
    //get the read 1-channal-dat and write 2-channal-dat path
    string WRITE_PATH,READ_PATH;
    conf::Instance()->Load(SYS_CONF);
    conf::Instance()->Get("write_path", WRITE_PATH);
    conf::Instance()->Get("read_path", READ_PATH);
    //get the filename and the last foldername
    memset(date_tmp, 0, _MAX_PATH);
    data_file_name = get_file_name(data_file_path);
    strncpy(ecg_file_name, data_file_name,_MAX_PATH);
    remove_extension(ecg_file_name);
    strncpy(date_tmp, data_file_path, strlen(data_file_path) - strlen(data_file_name) - 1);
    strncpy(date_path, get_file_name(date_tmp),_MAX_PATH);
    //get the full file path
    snprintf(ecg_filtered_data_file_path,_MAX_PATH, "%s/%s/%s.dat", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_annotation_file_path,_MAX_PATH, "%s/%s/%s.bsp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_head_file_path,_MAX_PATH, "%s/%s/%s.hea", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_tmp_file_path,_MAX_PATH, "%s/%s/%s.tmp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_config_file_path,_MAX_PATH, "%s/%s/%s.cnf", READ_PATH.c_str(), date_path, ecg_file_name);
    //variable initial
    Initial();
    //use the google_protobuf
    GOOGLE_PROTOBUF_VERIFY_VERSION;
    //Template tmp;
    temp::BeatTemplate *tmpN=tmp.add_beat_templates();
    temp::BeatTemplate *tmpA=tmp.add_beat_templates();
    temp::BeatTemplate *tmpV=tmp.add_beat_templates();
    temp::BeatTemplate *tmpS=tmp.add_beat_templates();
    tmpA->set_type(BeatTemplate::A);
    tmpN->set_type(BeatTemplate::N);
    tmpV->set_type(BeatTemplate::V);
    tmpS->set_type(BeatTemplate::S);
    //using in tmp
    int modeltypev[MAXTYPES+1];
    int modeltypen[MAXTYPES+1];
    for(int i=0;i<MAXTYPES+1;i++)
    {
        modeltypev[i] = 0;
        modeltypen[i] = 0;
    }
    std::vector< std::vector<int> > m_clusters;
    std::vector<int> m_type;
    std::vector<int> Q_type;
    std::vector<int> S_type;
    //write to annot
    WFDB_Annotation annotppre ;
    WFDB_Annotation annotpre ;
    WFDB_Annotation annot ;
    FILE *fileann = fopen(ecg_annotation_file_path,"wb");//

    //find QRS
    int delay;
    int InputFileSampleFrequency = 128;
    long SampleCount = 0;
    long DetectionTime = 0;
    int beatType, beatMatch ;
    lasttime =0;


    // Open a 1 channel record
    FILE* filed = fopen(data_file_path,"r");//
    if(!filed){
        printf("please check the file:%s!",data_file_path);
        return 0;
    }
    fseek(filed,0,2);
    long flend=ftell(filed); // 得到文件大小
    int lengthd = flend/3;
    int posd=0;              // read the 1-channal-locate, once by 3 chars
    char* lpc = new char[flend]; //read
    int* INlpc = new int[lengthd*2];//the real data in 1-channal-file
    int* OUTlpc = new int[lengthd*2];//the real data in 2-channal-file
    fseek(filed, 0, SEEK_SET);
    fread(lpc, flend,1,filed);
    int dataIN;

    //write to the 2-channal-dat file
    int file2c_lsize = flend*2;
    FILE* fp = fopen(ecg_filtered_data_file_path,"w");
    if (fp == NULL){
        printf("can't open the output 2-channel file!");
        return 0;
    }
    char *buf = new char[file2c_lsize];//(char *) malloc(file2c_lsize);
    char* lpc2 = (char *) buf;

    //write the head file
    FILE *filehea = fopen(ecg_head_file_path, "w");
    int sNum = 2;
    float sr = 128;
    int res = fprintf(filehea, "%s %d %3.0f %d\n", ecg_file_name, sNum, sr, file2c_lsize);
    int eNum = 0;
    int umv = 549, bits = 212, resolution = 12, zero = 0, crc = 0, firstdata = 0;
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s\n", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    fclose(filehea);

    int delnum=0;
    // Initialize beat detection and classification.
    BDAC bdac;
    bdac.ResetBDAC() ;                                                   //bdac.c
    int lpcount = 0;
    ///useinqrs
    int datahp[1000];
    int datapeak[1000];
    int datade[1000];
    int datadefabs[1000];
    for(int i=0;i<1000;i++){
        datahp[i] = 0;
        datapeak[i] = 0;
        datade[i] = 0;
        datadefabs[i] = 0;
    }
    int dataid=0;
    int qrsdata[72];
    int qrsde[72];
    int qrsfabs[72];
    data_qrs qrs_data;
    int qrslen = 1;
    int meanlen = 10;
    int sumlen = 0;
    int qrsmean[10];//存储峰值的数组
    int qrsmeannum[10];//存储峰值位置
    int meanid=0;//存储峰值数组的id位置
    int sumpeak = 0;//多个峰值和
    int meanpeak = 0;//峰值均值
    delay = 36+22;
    annot.time = 0;
    int countann = 0;
    int prenoraml = 0;
    // Read data from MIT/BIH file until tre is none left.
    while( posd < lengthd)  //local
    {
        if(SampleCount%2==0) {
            dataIN = MAKEWORD(lpc[posd * 3 ], (lpc[posd * 3 + 1 ] & 0x0f));
        }
        else {
            dataIN = MAKEWORD(lpc[posd * 3 + 2], (lpc[posd * 3 + 1] & 0xf0) >> 4);
            posd++;
        }

        if (dataIN & 0x800)
            dataIN |= ~(0xfff); //negative  data, make all the high bit(12 and after) 1
        else dataIN &= 0xfff;        //positive data, make all the hight bit 0
        ++SampleCount ;
        // Pass sample to beat detection and classification.
        delay = bdac.BeatDetectAndClassify(dataIN, &beatType, &beatMatch) ;    //bdac.c
        delay = 45;//36+22;
        //useinqrs
        datahp[dataid] = bdac.qrsdet1.dataqrs[2];
        datapeak[dataid] = bdac.qrsdet1.dataqrs[6];
        datade[dataid] = bdac.qrsdet1.dataqrs[3];
        datadefabs[dataid] = bdac.qrsdet1.dataqrs[4];
        //peak
        if(datapeak[dataid]>0 ){
            if(qrslen<10 && SampleCount > delay)
            {
                sumpeak+=datapeak[dataid];//累积前九个峰值的和
                qrsmean[meanid] = datapeak[dataid];
                qrsmeannum[meanid++] = SampleCount;
            }
            else if (qrslen==10){
                meanpeak = int((sumpeak+datapeak[dataid])*1.0/qrslen+0.5);//计算前十个峰值的均值
                qrsmean[meanid] = datapeak[dataid];
                qrsmeannum[meanid++] = SampleCount;
                if(meanpeak<30)
                    meanpeak = 30;
                sumpeak = 0;
                meanid=0;
                for(int i=0;i<10;i++){
                    if(qrsmean[i]>0.5*meanpeak && qrsmean[i]<2*meanpeak){
                        qrsmean[meanid++]=qrsmean[i]; //把该峰值存入计算峰值均值数组
                        sumpeak += qrsmean[i];        //计算数组内峰值和
                        sumlen++;                     //数组长度
                        DetectionTime = qrsmeannum[i] - delay ;
                        DetectionTime *= InputFileSampleFrequency ;
                        DetectionTime /= SAMPLE_RATE ;
                        if(annot.time>=DetectionTime){
                            continue;
                        }
                        annot.time = DetectionTime ;
                        annot.anntyp = 1 ;
                        annot.aux = NULL ;
                        putann2(fileann,&annot,lasttime,0);
                        //WRITE TO THE TMP
                        WRITE_THE_TMP2(annot.anntyp, bdac, m_clusters, m_type, Q_type, S_type,DetectionTime, modeltypen, modeltypev,&delnum);
                    }
                }
                meanpeak = (int)(sumpeak*1.0/sumlen+0.5);
            }
            else{
                countann++;
                if(annotpre.anntyp == 2 )
                {
                    if((SampleCount - delay - annotpre.time)<51)
                        annotpre.anntyp = 9;
                    else if( annotpre.height>0.5*prenoraml)
                        annotpre.anntyp = 1;
                    else
                        annotpre.anntyp = 9;
                }
                if(datapeak[dataid]>0.5*meanpeak && datapeak[dataid]<100){//2*meanpeak){
                    if(meanid>=10){
                        meanid=0;
                    }
                    if(sumlen<10){
                        qrsmean[meanid++]=datapeak[dataid]; //
                        sumpeak += datapeak[dataid];
                        sumlen++;
                        meanpeak = int(sumpeak*1.0/sumlen+0.5);
                    }
                    else if(datapeak[dataid]>0.75*meanpeak && datapeak[dataid]<1.25*meanpeak)
                    {
                        sumpeak += datapeak[dataid] - qrsmean[meanid];
                        meanpeak = int(sumpeak*1.0/meanlen+0.5);
                        qrsmean[meanid++]=datapeak[dataid];
                    }
                    beatType = 1;
                    if(meanpeak>50)
                        meanpeak = 50;
                    else if(meanpeak<10)
                        meanpeak =10;
                }
                else if(datapeak[dataid]>=100){//2*meanpeak){
                    beatType = 13;
                }
                else{
                    if(countann>2) {
                        if  (SampleCount - delay - annotpre.time < 51)
                            beatType = 9;
                        else{
                            beatType = 2;
                        }
                    }
                }
                DetectionTime = SampleCount - delay ;
                DetectionTime *= InputFileSampleFrequency ;
                DetectionTime /= SAMPLE_RATE ;
                if(annot.time>=DetectionTime){
                    continue;
                }
                annot.time = DetectionTime ;
                annot.anntyp = beatType;
                annot.height = datapeak[dataid];
                annot.aux = NULL ;


                if(countann>1){
                    putann2(fileann,&annotpre,lasttime,0);
                    //WRITE TO THE TMP
                    //WRITE_THE_TMP2(annotpre.anntyp, bdac, m_clusters, m_type, Q_type, S_type,DetectionTime, modeltypen, modeltypev,&delnum);
                    WRITE_THE_TMP2(annotpre.anntyp, bdac, m_clusters, m_type, Q_type, S_type,annotpre.time, modeltypen, modeltypev,&delnum);
                }
                if(countann==1){
                    memcpy(&annotpre,&annot,sizeof(annot));
                }
                else{
                    memcpy(&annotppre,&annotpre,sizeof(annotpre));
                    memcpy(&annotpre,&annot,sizeof(annot));
                    if (annotppre.anntyp==1)
                        prenoraml = annotppre.height;
                }
            }
            qrslen++;
        }


        //useinqrs
        dataid++;
        if(dataid>=1000)
            dataid=0;
        // printf("%d\n",SampleCount);
        // save the real-data
        OUTlpc[lpcount] =bdac.qrsdet1.datafilt;
        INlpc[lpcount++] = dataIN;
    }

//
    //2 int change to 3 chars
    int dif = LPBUFFER_LGTH/2-1+(HPBUFFER_LGTH-1)/2;
    for(int i=0;i<lengthd*2;i++)
    {
        int id = i+dif;
        if(id>=lengthd*2){
            id=lengthd*2-1;
        }
        lpc2[0] = LOBYTE((short) INlpc[i]);
        lpc2[1] = 0;
        lpc2[1] = HIBYTE((short) INlpc[i]) & 0x0f;
        lpc2[2] = LOBYTE((short) OUTlpc[id]);
        lpc2[1] |= HIBYTE((short) OUTlpc[id]) << 4;
        lpc2 += 3;
    }
    fwrite( buf, sizeof(char), file2c_lsize, fp);
    fclose(fp);//close the 2-channal-dat file
    delete[]buf;
    delete[]lpc;
    delete[]INlpc;
    delete[]OUTlpc;

    wfdb_p16(0, fileann);//STOP WRITE THE ATEST FILE
    fclose(fileann);//CLOSE WRITE THE annotion FILE
    fclose(filed); //CLOSE THE 1-channal-DAT FILE

    // Write the new address book back to disk.
    int Nnum = 0, Vnum=0, Anum = 0;
    int countN = 0,countV = 0,countA=0,countS=0;
    bool Nfind1 = false, Vfind1 = false, Afind1 = false;
    int Nfind1ID = 0, Vfind1ID = 0, Afind1ID = 0;
    fstream tempfile(ecg_tmp_file_path, ios::out | ios::trunc | ios::binary);
    Template1 *tmp1N = tmpN->add_template1s();
    tmp1N->set_id(0);
    Template1 *tmp1V = tmpV->add_template1s();
    tmp1V->set_id(0);
    Template1 *tmp1A = tmpA->add_template1s();
    tmp1A->set_id(0);
    Template1 *tmp1S = tmpS->add_template1s();
    tmp1S->set_id(0);

    if (Q_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1A->add_template2s();
        tmp1->set_id(0);
        countA += Q_type.size();
        for (int k = 0; k < Q_type.size(); k++) {
            tmp1->add_positions_of_beats(Q_type[k]);
        }
    }
    if (S_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1S->add_template2s();
        tmp1->set_id(0);
        countS += S_type.size();
        for (int k = 0; k < S_type.size(); k++) {
            tmp1->add_positions_of_beats(S_type[k]);
        }
    }
    if (m_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1N->add_template2s();
        tmp1->set_id(0);
        countN += m_type.size();
        for (int k = 0; k < m_type.size(); k++) {
            tmp1->add_positions_of_beats(m_type[k]);
        }
    }

    printf("all tmp = %d\n", Anum + Vnum +Nnum);
    if (!tmp.SerializeToOstream(&tempfile)) {
        cerr << "Failed to write address book." << endl;
        return -1;
    }
    google::protobuf::ShutdownProtobufLibrary();
//
    return 0;
}*/

//easy3

/*int TESTRECORD::TestRecord_qrs(const char *data_file_path)
{
    char *data_file_name;
    char date_tmp[_MAX_PATH]; //XXX/201414/
    char ecg_file_name[_MAX_PATH];
    char date_path[_MAX_PATH];
    char ecg_filtered_data_file_path[_MAX_PATH]; //saved file name
    char ecg_annotation_file_path[_MAX_PATH]; //saved file name
    char ecg_head_file_path[_MAX_PATH]; //saved file name           7
    char ecg_tmp_file_path[_MAX_PATH]; //saved file name           7
    char ecg_config_file_path[_MAX_PATH];// the path with config
    //get the read 1-channal-dat and write 2-channal-dat path
    string WRITE_PATH,READ_PATH;
    conf::Instance()->Load(SYS_CONF);
    conf::Instance()->Get("write_path", WRITE_PATH);
    conf::Instance()->Get("read_path", READ_PATH);
    //get the filename and the last foldername
    memset(date_tmp, 0, _MAX_PATH);
    data_file_name = get_file_name(data_file_path);
    strncpy(ecg_file_name, data_file_name,_MAX_PATH);
    remove_extension(ecg_file_name);
    strncpy(date_tmp, data_file_path, strlen(data_file_path) - strlen(data_file_name) - 1);
    strncpy(date_path, get_file_name(date_tmp),_MAX_PATH);
    //get the full file path
    snprintf(ecg_filtered_data_file_path,_MAX_PATH, "%s/%s/%s.dat", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_annotation_file_path,_MAX_PATH, "%s/%s/%s.bsp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_head_file_path,_MAX_PATH, "%s/%s/%s.hea", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_tmp_file_path,_MAX_PATH, "%s/%s/%s.tmp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_config_file_path,_MAX_PATH, "%s/%s/%s.cnf", READ_PATH.c_str(), date_path, ecg_file_name);
    //variable initial
    Initial();
    //use the google_protobuf
    GOOGLE_PROTOBUF_VERIFY_VERSION;
    //Template tmp;
    temp::BeatTemplate *tmpN=tmp.add_beat_templates();
    temp::BeatTemplate *tmpA=tmp.add_beat_templates();
    temp::BeatTemplate *tmpV=tmp.add_beat_templates();
    temp::BeatTemplate *tmpS=tmp.add_beat_templates();
    tmpA->set_type(BeatTemplate::A);
    tmpN->set_type(BeatTemplate::N);
    tmpV->set_type(BeatTemplate::V);
    tmpS->set_type(BeatTemplate::S);
    //using in tmp
    int modeltypev[MAXTYPES+1];
    int modeltypen[MAXTYPES+1];
    for(int i=0;i<MAXTYPES+1;i++)
    {
        modeltypev[i] = 0;
        modeltypen[i] = 0;
    }
    std::vector< std::vector<int> > m_clusters;
    std::vector<int> m_type;
    std::vector<int> Q_type;
    std::vector<int> S_type;
    std::vector<int> V_type;
    //write to annot
    WFDB_Annotation annotppre ;
    WFDB_Annotation annotpre ;
    WFDB_Annotation annot ;
    FILE *fileann = fopen(ecg_annotation_file_path,"wb");//

    //find QRS
    int delay = 45;
    int InputFileSampleFrequency = 128;
    long SampleCount = 0;
    long DetectionTime = 0;
    int beatType, beatMatch ;
    lasttime =0;


    // Open a 1 channel record
    FILE* filed = fopen(data_file_path,"r");//
    if(!filed){
        printf("please check the file:%s!",data_file_path);
        return 0;
    }
    fseek(filed,0,2);
    long flend=ftell(filed); // 得到文件大小
    int lengthd = flend/3;
    int posd=0;              // read the 1-channal-locate, once by 3 chars
    char* lpc = new char[flend]; //read
    int* INlpc = new int[lengthd*2];//the real data in 1-channal-file
    int* OUTlpc = new int[lengthd*2];//the real data in 2-channal-file
    fseek(filed, 0, SEEK_SET);
    fread(lpc, flend,1,filed);
    int dataIN;

    //write to the 2-channal-dat file
    int file2c_lsize = flend*2;
    FILE* fp = fopen(ecg_filtered_data_file_path,"w");
    if (fp == NULL){
        printf("can't open the output 2-channel file!");
        return 0;
    }
    char *buf = new char[file2c_lsize];//(char *) malloc(file2c_lsize);
    char* lpc2 = (char *) buf;

    //write the head file
    FILE *filehea = fopen(ecg_head_file_path, "w");
    int sNum = 2;
    float sr = 128;
    int res = fprintf(filehea, "%s %d %3.0f %d\n", ecg_file_name, sNum, sr, file2c_lsize);
    int eNum = 0;
    int umv = 549, bits = 212, resolution = 12, zero = 0, crc = 0, firstdata = 0;
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s\n", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    fclose(filehea);

    int delnum=0;
    // Initialize beat detection and classification.
    BDAC bdac;
    bdac.ResetBDAC() ;                                                   //bdac.c
    int lpcount = 0;
    ///useinqrs
    int datahp[1000];
    int datapeak[1000];
    int datade[1000];
    int datadefabs[1000];
    for(int i=0;i<1000;i++){
        datahp[i] = 0;
        datapeak[i] = 0;
        datade[i] = 0;
        datadefabs[i] = 0;
    }
    int dataid=0;

    int qrsdata[72];
    int qrsde[72];
    int qrsfabs[72];
    data_qrs qrs_data;
    int qrslen = 1;
    int meanlen = 10;
    int sumlen = 0;
    int qrsmean[10];//存储峰值的数组
    int qrsmeannum[10];//存储峰值位置
    for(int i=0;i<10;i++){
        qrsmean[i] = 0;
        qrsmeannum[i] = 0;
    }
    int meanid=0;//存储峰值数组的id位置
    int sumpeak = 0;//多个峰值和
    int meanpeak = 0;//峰值均值
    annot.time = 0;
    int countann = 0;
    int prenoraml = 0;
    int data[41];//qrs 41points around qrs
    // Read data from MIT/BIH file until tre is none left.
    while( posd < lengthd)  //local
    {
        if(SampleCount%2==0) {
            dataIN = MAKEWORD(lpc[posd * 3 ], (lpc[posd * 3 + 1 ] & 0x0f));
        }
        else {
            dataIN = MAKEWORD(lpc[posd * 3 + 2], (lpc[posd * 3 + 1] & 0xf0) >> 4);
            posd++;
        }

        if (dataIN & 0x800)
            dataIN |= ~(0xfff); //negative  data, make all the high bit(12 and after) 1
        else dataIN &= 0xfff;        //positive data, make all the hight bit 0
        ++SampleCount ;
        // Pass sample to beat detection and classification.
        delay = bdac.BeatDetectAndClassify(dataIN, &beatType, &beatMatch) ;    //bdac.c
        delay = 45;//36+22;
        //useinqrs
        datahp[dataid] = bdac.qrsdet1.dataqrs[2];
        datapeak[dataid] = bdac.qrsdet1.dataqrs[6];
        datade[dataid] = bdac.qrsdet1.dataqrs[3];
        datadefabs[dataid] = bdac.qrsdet1.dataqrs[4];
        //peak
        if(datapeak[dataid]>0 ){
            if(qrslen<10 && SampleCount > delay)
            {
                sumpeak+=datapeak[dataid];//累积前九个峰值的和
                qrsmean[meanid] = datapeak[dataid];
                qrsmeannum[meanid++] = SampleCount;
            }
            else if (qrslen==10){
                meanpeak = int((sumpeak+datapeak[dataid])*1.0/qrslen+0.5);//计算前十个峰值的均值
                qrsmean[meanid] = datapeak[dataid];
                qrsmeannum[meanid++] = SampleCount;
                if(meanpeak<30)
                    meanpeak = 30;
                sumpeak = 0;
                meanid=0;
                for(int i=0;i<10;i++){
                    if(qrsmean[i]>0.5*meanpeak && qrsmean[i]<2*meanpeak){
                        qrsmean[meanid++]=qrsmean[i]; //把该峰值存入计算峰值均值数组
                        sumpeak += qrsmean[i];        //计算数组内峰值和
                        sumlen++;                     //数组长度
                        DetectionTime = qrsmeannum[i] - delay ;
                        DetectionTime *= InputFileSampleFrequency ;
                        DetectionTime /= SAMPLE_RATE ;
                        if(annot.time>=DetectionTime){
                            continue;
                        }
                        annot.time = DetectionTime ;
                        annot.anntyp = 1 ;
                        annot.aux = NULL ;
                        putann2(fileann,&annot,lasttime,0);
                        //WRITE TO THE TMP
                        WRITE_THE_TMP2(annot.anntyp, bdac, m_clusters, m_type, Q_type, S_type,DetectionTime, modeltypen, modeltypev,&delnum);
                    }
                }
                meanpeak = (int)(sumpeak*1.0/sumlen+0.5);
            }
            else{
                countann++;
                if(annotpre.anntyp == 2 )
                {
                    if((SampleCount - delay - annotpre.time)<51)
                        annotpre.anntyp = 9;
                    else if( annotpre.height>0.5*prenoraml && annotpre.height>0.8*annotpre.height)
                        annotpre.anntyp = 1;
                    else
                        annotpre.anntyp = 9;
                }
                if(datapeak[dataid]>0.5*meanpeak && datapeak[dataid]<100){//2*meanpeak){
                    if(meanid>=10){
                        meanid=0;
                    }
                    if(sumlen<10){
                        qrsmean[meanid++]=datapeak[dataid]; //
                        sumpeak += datapeak[dataid];
                        sumlen++;
                        meanpeak = int(sumpeak*1.0/sumlen+0.5);
                    }
                    else if(datapeak[dataid]>0.75*meanpeak && datapeak[dataid]<1.25*meanpeak)
                    {
                        sumpeak += datapeak[dataid] - qrsmean[meanid];
                        meanpeak = int(sumpeak*1.0/meanlen+0.5);
                        qrsmean[meanid++]=datapeak[dataid];
                    }
                    beatType = 1;
                    if(meanpeak>50)
                        meanpeak = 50;
                    else if(meanpeak<10)
                        meanpeak =10;
                }
                else if(datapeak[dataid]>=100){//2*meanpeak){
                    if(datapeak[dataid]>1.5*prenoraml)
                        beatType = 13;
                    else{
                        beatType =1;
                    }
                }
                else{
                    if(countann>2) {
                        if  (SampleCount - delay - annotpre.time < 51)
                            beatType = 9;
                        else{
                            beatType = 2;
                        }
                    }
                }
                DetectionTime = SampleCount - delay ;
                DetectionTime *= InputFileSampleFrequency ;
                DetectionTime /= SAMPLE_RATE ;
                if(annot.time>=DetectionTime){
                    continue;
                }
                annot.time = DetectionTime ;
                annot.anntyp = beatType;
                annot.height = datapeak[dataid];
                annot.aux = NULL ;

                if(countann>1){
                    if(annotpre.anntyp==1 ){
                        int diftime=annot.time-annotpre.time;
                        if(diftime<940){
                            int noid=dataid-delay-diftime-12;
                            if (noid<0)
                                noid +=1000;
                            double sumround = 0;
                            double sumqrs = 0;
                            int mk=0;
                            //int data[41];
                            for(mk;mk<41;mk++){
                                if(mk<10||mk>30){
                                    sumround += datahp[noid]*datahp[noid];
                                }
                                else{
                                    sumqrs+=datahp[noid]*datahp[noid];
                                }
                                data[mk] = datahp[noid];
                                noid++;
                                if(noid>=1000)
                                    noid=0;
                            }
                            sumround = sqrt(sumround*1.0/20.0);
                            sumqrs = sqrt(sumqrs*1.0/21.0)*0.5;

                            if(sumround>sumqrs){
                                //printf("DETECTION = %d, sumround = %f, sumqrs = %f\n",annotpre.time, sumround,sumqrs);
                                annotpre.anntyp = 5;
                            }

                        }
                    }
                    putann2(fileann,&annotpre,lasttime,0);
                    //WRITE TO THE TMP
                    //WRITE_THE_TMP2(annotpre.anntyp, bdac, m_clusters, m_type, Q_type, S_type,DetectionTime, modeltypen, modeltypev,&delnum);
                    WRITE_THE_TMP3(annotpre.anntyp, m_type, Q_type, S_type, V_type, annotpre.time);
                }
                if(countann==1){
                    memcpy(&annotpre,&annot,sizeof(annot));
                }
                else{
                    memcpy(&annotppre,&annotpre,sizeof(annotpre));
                    memcpy(&annotpre,&annot,sizeof(annot));
                    if (annotppre.anntyp==1)
                        prenoraml = annotppre.height;
                }
            }
            qrslen++;
        }


        //useinqrs
        dataid++;
        if(dataid>=1000)
            dataid=0;
        // printf("%d\n",SampleCount);
        // save the real-data
        OUTlpc[lpcount] =bdac.qrsdet1.datafilt;
        INlpc[lpcount++] = dataIN;
    }

//
    //2 int change to 3 chars
    int dif = LPBUFFER_LGTH/2-1+(HPBUFFER_LGTH-1)/2;
    for(int i=0;i<lengthd*2;i++)
    {
        int id = i+dif;
        if(id>=lengthd*2){
            id=lengthd*2-1;
        }
        lpc2[0] = LOBYTE((short) INlpc[i]);
        lpc2[1] = 0;
        lpc2[1] = HIBYTE((short) INlpc[i]) & 0x0f;
        lpc2[2] = LOBYTE((short) OUTlpc[id]);
        lpc2[1] |= HIBYTE((short) OUTlpc[id]) << 4;
        lpc2 += 3;
    }
    fwrite( buf, sizeof(char), file2c_lsize, fp);
    fclose(fp);//close the 2-channal-dat file
    delete[]buf;
    delete[]lpc;
    delete[]INlpc;
    delete[]OUTlpc;

    wfdb_p16(0, fileann);//STOP WRITE THE ATEST FILE
    fclose(fileann);//CLOSE WRITE THE annotion FILE
    fclose(filed); //CLOSE THE 1-channal-DAT FILE

    // Write the new address book back to disk.
    int Nnum = 0, Vnum=0, Anum = 0;
    int countN = 0,countV = 0,countA=0,countS=0;
    bool Nfind1 = false, Vfind1 = false, Afind1 = false;
    int Nfind1ID = 0, Vfind1ID = 0, Afind1ID = 0;
    fstream tempfile(ecg_tmp_file_path, ios::out | ios::trunc | ios::binary);
    Template1 *tmp1N = tmpN->add_template1s();
    tmp1N->set_id(0);
    Template1 *tmp1V = tmpV->add_template1s();
    tmp1V->set_id(0);
    Template1 *tmp1A = tmpA->add_template1s();
    tmp1A->set_id(0);
    Template1 *tmp1S = tmpS->add_template1s();
    tmp1S->set_id(0);

    if (Q_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1A->add_template2s();
        tmp1->set_id(0);
        countA += Q_type.size();
        for (int k = 0; k < Q_type.size(); k++) {
            tmp1->add_positions_of_beats(Q_type[k]);
        }
    }
    if (V_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1V->add_template2s();
        tmp1->set_id(0);
        countV += V_type.size();
        for (int k = 0; k < V_type.size(); k++) {
            tmp1->add_positions_of_beats(V_type[k]);
        }
    }
    if (S_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1S->add_template2s();
        tmp1->set_id(0);
        countS += S_type.size();
        for (int k = 0; k < S_type.size(); k++) {
            tmp1->add_positions_of_beats(S_type[k]);
        }
    }
    if (m_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1N->add_template2s();
        tmp1->set_id(0);
        countN += m_type.size();
        for (int k = 0; k < m_type.size(); k++) {
            tmp1->add_positions_of_beats(m_type[k]);
        }
    }

    //printf("all tmp = %d\n", Anum + Vnum +Nnum);
    printf("normal = %d\n",m_type.size());
    printf("PVC = %d\n",V_type.size());
    printf("Q = %d\n",Q_type.size());
    printf("S = %d\n",S_type.size());
    if (!tmp.SerializeToOstream(&tempfile)) {
        cerr << "Failed to write address book." << endl;
        return -1;
    }
    google::protobuf::ShutdownProtobufLibrary();
//
    return 0;
}*/

//m205num2,结果只有normal和q

/*int TESTRECORD::TestRecord_qrs(const char *data_file_path)
{
    char *data_file_name;
    char date_tmp[_MAX_PATH]; //XXX/201414/
    char ecg_file_name[_MAX_PATH];
    char date_path[_MAX_PATH];
    char ecg_filtered_data_file_path[_MAX_PATH]; //saved file name
    char ecg_annotation_file_path[_MAX_PATH]; //saved file name
    char ecg_head_file_path[_MAX_PATH]; //saved file name           7
    char ecg_tmp_file_path[_MAX_PATH]; //saved file name           7
    char ecg_config_file_path[_MAX_PATH];// the path with config
    //get the read 1-channal-dat and write 2-channal-dat path
    string WRITE_PATH,READ_PATH;
    conf::Instance()->Load(SYS_CONF);
    conf::Instance()->Get("write_path", WRITE_PATH);
    conf::Instance()->Get("read_path", READ_PATH);
    //get the filename and the last foldername
    memset(date_tmp, 0, _MAX_PATH);
    data_file_name = get_file_name(data_file_path);
    strncpy(ecg_file_name, data_file_name,_MAX_PATH);
    remove_extension(ecg_file_name);
    strncpy(date_tmp, data_file_path, strlen(data_file_path) - strlen(data_file_name) - 1);
    strncpy(date_path, get_file_name(date_tmp),_MAX_PATH);
    //get the full file path
    snprintf(ecg_filtered_data_file_path,_MAX_PATH, "%s/%s/%s.dat", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_annotation_file_path,_MAX_PATH, "%s/%s/%s.bsp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_head_file_path,_MAX_PATH, "%s/%s/%s.hea", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_tmp_file_path,_MAX_PATH, "%s/%s/%s.tmp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_config_file_path,_MAX_PATH, "%s/%s/%s.cnf", READ_PATH.c_str(), date_path, ecg_file_name);
    //variable initial
    Initial();
    //use the google_protobuf
    GOOGLE_PROTOBUF_VERIFY_VERSION;
    //Template tmp;
    temp::BeatTemplate *tmpN=tmp.add_beat_templates();
    temp::BeatTemplate *tmpA=tmp.add_beat_templates();
    temp::BeatTemplate *tmpV=tmp.add_beat_templates();
    temp::BeatTemplate *tmpS=tmp.add_beat_templates();
    tmpA->set_type(BeatTemplate::A);
    tmpN->set_type(BeatTemplate::N);
    tmpV->set_type(BeatTemplate::V);
    tmpS->set_type(BeatTemplate::S);
    //using in tmp
    int modeltypev[MAXTYPES+1];
    int modeltypen[MAXTYPES+1];
    for(int i=0;i<MAXTYPES+1;i++)
    {
        modeltypev[i] = 0;
        modeltypen[i] = 0;
    }
    std::vector< std::vector<int> > m_clusters;
    std::vector<int> m_type;
    std::vector<int> Q_type;
    std::vector<int> S_type;
    std::vector<int> V_type;
    //write to annot
    WFDB_Annotation annotppre ;
    WFDB_Annotation annotpre ;
    WFDB_Annotation annot ;
    FILE *fileann = fopen(ecg_annotation_file_path,"wb");//

    //find QRS
    int delay = 45;
    int InputFileSampleFrequency = 128;
    long SampleCount = 0;
    long DetectionTime = 0;
    int beatType, beatMatch ;
    lasttime =0;


    // Open a 1 channel record
    FILE* filed = fopen(data_file_path,"r");//
    if(!filed){
        printf("please check the file:%s!",data_file_path);
        return 0;
    }
    fseek(filed,0,2);
    long flend=ftell(filed); // 得到文件大小
    int lengthd = flend/3;
    int posd=0;              // read the 1-channal-locate, once by 3 chars
    char* lpc = new char[flend]; //read
    int* INlpc = new int[lengthd*2];//the real data in 1-channal-file
    int* OUTlpc = new int[lengthd*2];//the real data in 2-channal-file
    fseek(filed, 0, SEEK_SET);
    fread(lpc, flend,1,filed);
    int dataIN;

    //write to the 2-channal-dat file
    int file2c_lsize = flend*2;
    FILE* fp = fopen(ecg_filtered_data_file_path,"w");
    if (fp == NULL){
        printf("can't open the output 2-channel file!");
        return 0;
    }
    char *buf = new char[file2c_lsize];//(char *) malloc(file2c_lsize);
    char* lpc2 = (char *) buf;

    //write the head file
    FILE *filehea = fopen(ecg_head_file_path, "w");
    int sNum = 2;
    float sr = 128;
    int res = fprintf(filehea, "%s %d %3.0f %d\n", ecg_file_name, sNum, sr, file2c_lsize);
    int eNum = 0;
    int umv = 549, bits = 212, resolution = 12, zero = 0, crc = 0, firstdata = 0;
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s\n", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    fclose(filehea);

    int delnum=0;
    // Initialize beat detection and classification.
    BDAC bdac;
    bdac.ResetBDAC() ;                                                   //bdac.c
    int lpcount = 0;
    ///useinqrs
    int datahp[1000];
    int datapeak[1000];
    int datade[1000];
    int datadefabs[1000];
    for(int i=0;i<1000;i++){
        datahp[i] = 0;
        datapeak[i] = 0;
        datade[i] = 0;
        datadefabs[i] = 0;
    }
    int dataid=0;

    int qrslen = 1;
    int meanlen = 10;
    int sumlen = 0;
    int qrsmean[10];//存储峰值的数组
    int qrsmeannum[10];//存储峰值位置
    for(int i=0;i<10;i++){
        qrsmean[i] = 0;
        qrsmeannum[i] = 0;
    }
    int meanid=0;//存储峰值数组的id位置
    int sumpeak = 0;//多个峰值和
    int meanpeak = 0;//峰值均值
    annot.time = 0;
    int countann = 0;
    int prenoraml = 0;
    int data[41];//qrs 41points around qrs
    // Read data from MIT/BIH file until tre is none left.
    while( posd < lengthd)  //local
    {
        if(SampleCount%2==0) {
            dataIN = MAKEWORD(lpc[posd * 3 ], (lpc[posd * 3 + 1 ] & 0x0f));
        }
        else {
            dataIN = MAKEWORD(lpc[posd * 3 + 2], (lpc[posd * 3 + 1] & 0xf0) >> 4);
            posd++;
        }

        if (dataIN & 0x800)
            dataIN |= ~(0xfff); //negative  data, make all the high bit(12 and after) 1
        else dataIN &= 0xfff;        //positive data, make all the hight bit 0
        ++SampleCount ;
        // Pass sample to beat detection and classification.
        delay = bdac.BeatDetectAndClassify(dataIN, &beatType, &beatMatch) ;    //bdac.c
        delay = 45;//36+22;
        //useinqrs
        datahp[dataid] = bdac.qrsdet1.dataqrs[2];
        datapeak[dataid] = bdac.qrsdet1.dataqrs[6];
        datade[dataid] = bdac.qrsdet1.dataqrs[3];
        datadefabs[dataid] = bdac.qrsdet1.dataqrs[4];
        //peak
        if(datapeak[dataid]>0 ){
            if(qrslen<10 && SampleCount > delay)
            {
                sumpeak+=datapeak[dataid];//累积前九个峰值的和
                qrsmean[meanid] = datapeak[dataid];
                qrsmeannum[meanid++] = SampleCount;
            }
            else if (qrslen==10){
                meanpeak = int((sumpeak+datapeak[dataid])*1.0/qrslen+0.5);//计算前十个峰值的均值
                qrsmean[meanid] = datapeak[dataid];
                qrsmeannum[meanid++] = SampleCount;
                if(meanpeak<30)
                    meanpeak = 30;
                sumpeak = 0;
                meanid=0;
                for(int i=0;i<10;i++){
                    if(qrsmean[i]>0.5*meanpeak && qrsmean[i]<2*meanpeak){
                        qrsmean[meanid++]=qrsmean[i]; //把该峰值存入计算峰值均值数组
                        sumpeak += qrsmean[i];        //计算数组内峰值和
                        sumlen++;                     //数组长度
                        DetectionTime = qrsmeannum[i] - delay ;
                        DetectionTime *= InputFileSampleFrequency ;
                        DetectionTime /= SAMPLE_RATE ;
                        if(annot.time>=DetectionTime){
                            continue;
                        }
                        annot.time = DetectionTime ;
                        annot.anntyp = 1 ;
                        annot.aux = NULL ;
                        putann2(fileann,&annot,lasttime,0);
                        //WRITE TO THE TMP
                        WRITE_THE_TMP2(annot.anntyp, bdac, m_clusters, m_type, Q_type, S_type,DetectionTime, modeltypen, modeltypev,&delnum);
                    }
                }
                meanpeak = (int)(sumpeak*1.0/sumlen+0.5);
            }
            else{
                countann++;
                if(annotpre.anntyp == 2 )
                {
                    if((SampleCount - delay - annotpre.time)<51)
                        annotpre.anntyp = 9;
                    else if( annotpre.height>0.5*prenoraml && annotpre.height>0.8*annotpre.height)
                        annotpre.anntyp = 1;
                    else
                        annotpre.anntyp = 9;
                }
                if(datapeak[dataid]>0.5*meanpeak && datapeak[dataid]<100){//2*meanpeak){
                    if(meanid>=10){
                        meanid=0;
                    }
                    if(sumlen<10){
                        qrsmean[meanid++]=datapeak[dataid]; //
                        sumpeak += datapeak[dataid];
                        sumlen++;
                        meanpeak = int(sumpeak*1.0/sumlen+0.5);
                    }
                    else if(datapeak[dataid]>0.75*meanpeak && datapeak[dataid]<1.25*meanpeak)
                    {
                        sumpeak += datapeak[dataid] - qrsmean[meanid];
                        meanpeak = int(sumpeak*1.0/meanlen+0.5);
                        qrsmean[meanid++]=datapeak[dataid];
                    }
                    beatType = 1;
                    if(meanpeak>50)
                        meanpeak = 50;
                    else if(meanpeak<10)
                        meanpeak =10;
                }
                else if(datapeak[dataid]>=100){//2*meanpeak){
                    if(datapeak[dataid]>1.5*prenoraml)
                        beatType = 13;
                    else{
                        beatType =1;
                    }
                }
                else{
                    if(countann>2) {
                        if  (SampleCount - delay - annotpre.time < 51)
                            beatType = 9;
                        else{
                            beatType = 2;
                        }
                    }
                }
                DetectionTime = SampleCount - delay ;
                DetectionTime *= InputFileSampleFrequency ;
                DetectionTime /= SAMPLE_RATE ;
                if(annot.time>=DetectionTime){
                    continue;
                }
                //annot.time = DetectionTime ;
                annot.anntyp = beatType;
                //annot.height = datapeak[dataid];
                annot.aux = NULL ;

                if(annot.anntyp == 1){ //根据qrs和周边的能量比，判断qrs是否是噪声
                    int noid=dataid-delay-12;
                    if (noid<0)
                        noid +=1000;
                    double sumround = 0;
                    double sumqrs = 0;
                    int mk=0;
                    //int data[41];
                    for(mk;mk<41;mk++){
                        if(mk<10||mk>30){
                            sumround += datahp[noid]*datahp[noid];
                        }
                        else{
                            sumqrs+=datahp[noid]*datahp[noid];
                        }
                        data[mk] = datahp[noid];
                        noid++;
                        if(noid>=1000)
                            noid=0;
                    }
                    sumround = sqrt(sumround*1.0/20.0);
                    sumqrs = sqrt(sumqrs*1.0/21.0)*0.5;

                    if(sumround>sumqrs){
                        annot.anntyp = 13;
                    }
                }
                int maxdn=0,mindn = 1000,maxid = 10,minid =10; //计算中心点左右最大最小值及其位置
                for(int i=20;i>10;i--)
                {
                    if(data[i]>maxdn){
                        maxdn=data[i];
                        maxid = i;
                    }
                    if(data[i]<mindn){
                        mindn = data[i];
                        minid = i;
                    }
                }
                int maxdnr=0,mindnr = 1000,maxidr = 21,minidr =21;
                for(int i=21;i<31;i++)
                {
                    if(data[i]>maxdnr){
                        maxdnr=data[i];
                        maxidr = i;
                    }
                    if(data[i]<mindnr){
                        mindnr = data[i];
                        minidr = i;
                    }
                }

                annot.width = minidr-minid;
                annot.height =max(maxdn,maxdnr)-min(mindn,mindnr);
                if(annot.time!=0)
                    annot.rr = DetectionTime - annot.time;
                annot.time = DetectionTime;
                if(countann>1){
                    if(annotpre.anntyp == 9){
                        memcpy(&annotpre,&annot,sizeof(annot));
                    }
                    else {
                        putann2(fileann, &annotpre, lasttime, 0);
                        //WRITE TO THE TMP
                        WRITE_THE_TMP3(annotpre.anntyp, m_type, Q_type, S_type, V_type, annotpre.time);
                        memcpy(&annotppre, &annotpre, sizeof(annotpre));
                        memcpy(&annotpre, &annot, sizeof(annot));
                        if (annotppre.anntyp == 1)
                            prenoraml = annotppre.height;
                    }
                }
                else //(countann==1){
                    memcpy(&annotpre,&annot,sizeof(annot));

            }
            qrslen++;
        }


        //useinqrs
        dataid++;
        if(dataid>=1000)
            dataid=0;
        // printf("%d\n",SampleCount);
        // save the real-data
        OUTlpc[lpcount] =bdac.qrsdet1.datafilt;
        INlpc[lpcount++] = dataIN;
    }

//
    //2 int change to 3 chars
    int dif = LPBUFFER_LGTH/2-1+(HPBUFFER_LGTH-1)/2;
    for(int i=0;i<lengthd*2;i++)
    {
        int id = i+dif;
        if(id>=lengthd*2){
            id=lengthd*2-1;
        }
        lpc2[0] = LOBYTE((short) INlpc[i]);
        lpc2[1] = 0;
        lpc2[1] = HIBYTE((short) INlpc[i]) & 0x0f;
        lpc2[2] = LOBYTE((short) OUTlpc[id]);
        lpc2[1] |= HIBYTE((short) OUTlpc[id]) << 4;
        lpc2 += 3;
    }
    fwrite( buf, sizeof(char), file2c_lsize, fp);
    fclose(fp);//close the 2-channal-dat file
    delete[]buf;
    delete[]lpc;
    delete[]INlpc;
    delete[]OUTlpc;

    wfdb_p16(0, fileann);//STOP WRITE THE ATEST FILE
    fclose(fileann);//CLOSE WRITE THE annotion FILE
    fclose(filed); //CLOSE THE 1-channal-DAT FILE

    // Write the new address book back to disk.
    int Nnum = 0, Vnum=0, Anum = 0;
    int countN = 0,countV = 0,countA=0,countS=0;
    bool Nfind1 = false, Vfind1 = false, Afind1 = false;
    int Nfind1ID = 0, Vfind1ID = 0, Afind1ID = 0;
    fstream tempfile(ecg_tmp_file_path, ios::out | ios::trunc | ios::binary);
    Template1 *tmp1N = tmpN->add_template1s();
    tmp1N->set_id(0);
    Template1 *tmp1V = tmpV->add_template1s();
    tmp1V->set_id(0);
    Template1 *tmp1A = tmpA->add_template1s();
    tmp1A->set_id(0);
    Template1 *tmp1S = tmpS->add_template1s();
    tmp1S->set_id(0);

    if (Q_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1A->add_template2s();
        tmp1->set_id(0);
        countA += Q_type.size();
        for (int k = 0; k < Q_type.size(); k++) {
            tmp1->add_positions_of_beats(Q_type[k]);
        }
    }
    if (V_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1V->add_template2s();
        tmp1->set_id(0);
        countV += V_type.size();
        for (int k = 0; k < V_type.size(); k++) {
            tmp1->add_positions_of_beats(V_type[k]);
        }
    }
    if (S_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1S->add_template2s();
        tmp1->set_id(0);
        countS += S_type.size();
        for (int k = 0; k < S_type.size(); k++) {
            tmp1->add_positions_of_beats(S_type[k]);
        }
    }
    if (m_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1N->add_template2s();
        tmp1->set_id(0);
        countN += m_type.size();
        for (int k = 0; k < m_type.size(); k++) {
            tmp1->add_positions_of_beats(m_type[k]);
        }
    }

    //printf("all tmp = %d\n", Anum + Vnum +Nnum);
    printf("normal = %d\n",m_type.size());
    printf("PVC = %d\n",V_type.size());
    printf("Q = %d\n",Q_type.size());
    printf("S = %d\n",S_type.size());
    if (!tmp.SerializeToOstream(&tempfile)) {
        cerr << "Failed to write address book." << endl;
        return -1;
    }
    google::protobuf::ShutdownProtobufLibrary();
//
    return 0;
}*/

//v0.1, The first somewhat satisfactory version,

/*int TESTRECORD::TestRecord_qrs(const char *data_file_path)
{
    char *data_file_name;
    char date_tmp[_MAX_PATH]; //XXX/201414/
    char ecg_file_name[_MAX_PATH];
    char date_path[_MAX_PATH];
    char ecg_filtered_data_file_path[_MAX_PATH]; //saved file name
    char ecg_annotation_file_path[_MAX_PATH]; //saved file name
    char ecg_head_file_path[_MAX_PATH]; //saved file name           7
    char ecg_tmp_file_path[_MAX_PATH]; //saved file name           7
    char ecg_config_file_path[_MAX_PATH];// the path with config
    //get the read 1-channal-dat and write 2-channal-dat path
    string WRITE_PATH,READ_PATH;
    conf::Instance()->Load(SYS_CONF);
    conf::Instance()->Get("write_path", WRITE_PATH);
    conf::Instance()->Get("read_path", READ_PATH);
    //get the filename and the last foldername
    memset(date_tmp, 0, _MAX_PATH);
    data_file_name = get_file_name(data_file_path);
    strncpy(ecg_file_name, data_file_name,_MAX_PATH);
    remove_extension(ecg_file_name);
    strncpy(date_tmp, data_file_path, strlen(data_file_path) - strlen(data_file_name) - 1);
    strncpy(date_path, get_file_name(date_tmp),_MAX_PATH);
    //get the full file path
    snprintf(ecg_filtered_data_file_path,_MAX_PATH, "%s/%s/%s.dat", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_annotation_file_path,_MAX_PATH, "%s/%s/%s.bsp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_head_file_path,_MAX_PATH, "%s/%s/%s.hea", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_tmp_file_path,_MAX_PATH, "%s/%s/%s.tmp", WRITE_PATH.c_str(), date_path, ecg_file_name);
    snprintf(ecg_config_file_path,_MAX_PATH, "%s/%s/%s.cnf", READ_PATH.c_str(), date_path, ecg_file_name);
    //variable initial
    Initial();
    //use the google_protobuf
    GOOGLE_PROTOBUF_VERIFY_VERSION;
    //Template tmp;
    temp::BeatTemplate *tmpN=tmp.add_beat_templates();
    temp::BeatTemplate *tmpA=tmp.add_beat_templates();
    temp::BeatTemplate *tmpV=tmp.add_beat_templates();
    temp::BeatTemplate *tmpS=tmp.add_beat_templates();
    tmpA->set_type(BeatTemplate::A);
    tmpN->set_type(BeatTemplate::N);
    tmpV->set_type(BeatTemplate::V);
    tmpS->set_type(BeatTemplate::S);
    //using in tmp
    int modeltypev[MAXTYPES+1];
    int modeltypen[MAXTYPES+1];
    for(int i=0;i<MAXTYPES+1;i++)
    {
        modeltypev[i] = 0;
        modeltypen[i] = 0;
    }
    std::vector< std::vector<int> > m_clusters;
    std::vector<int> m_type;
    std::vector<int> Q_type;
    std::vector<int> S_type;
    std::vector<int> V_type;
    //write to annot
    WFDB_Annotation annotppre ;
    WFDB_Annotation annotpre ;
    WFDB_Annotation annot ;
    FILE *fileann = fopen(ecg_annotation_file_path,"wb");//

    //find QRS
    int delay = 45;
    int InputFileSampleFrequency = 128;
    long SampleCount = 0;
    long DetectionTime = 0;
    int beatType=13, beatMatch=0 ;
    lasttime =0;


    // Open a 1 channel record
    FILE* filed = fopen(data_file_path,"r");//
    if(!filed){
        printf("please check the file:%s!",data_file_path);
        return 0;
    }
    fseek(filed,0,2);
    long flend=ftell(filed); // 得到文件大小
    int lengthd = flend/3;
    int posd=0;              // read the 1-channal-locate, once by 3 chars
    char* lpc = new char[flend]; //read
    int* INlpc = new int[lengthd*2];//the real data in 1-channal-file
    int* OUTlpc = new int[lengthd*2];//the real data in 2-channal-file
    fseek(filed, 0, SEEK_SET);
    fread(lpc, flend,1,filed);
    int dataIN;

    //write to the 2-channal-dat file
    int file2c_lsize = flend*2;
    FILE* fp = fopen(ecg_filtered_data_file_path,"w");
    if (fp == NULL){
        printf("can't open the output 2-channel file!");
        return 0;
    }
    char *buf = new char[file2c_lsize];//(char *) malloc(file2c_lsize);
    char* lpc2 = (char *) buf;

    //write the head file
    FILE *filehea = fopen(ecg_head_file_path, "w");
    int sNum = 2;
    float sr = 128;
    int res = fprintf(filehea, "%s %d %3.0f %d\n", ecg_file_name, sNum, sr, file2c_lsize);
    int eNum = 0;
    int umv = 549, bits = 212, resolution = 12, zero = 0, crc = 0, firstdata = 0;
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s\n", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    res = fprintf(filehea, "%s.dat %d %d %d %d %d %d %d %s", ecg_file_name, bits, umv, resolution, zero, firstdata, crc, 0, "v5");
    fclose(filehea);

    int delnum=0;
    // Initialize beat detection and classification.
    BDAC bdac;
    bdac.ResetBDAC() ;                                                   //bdac.c
    int lpcount = 0;
    ///useinqrs
    int datahp[1000];
    int datapeak[1000];
    int datade[1000];
    int datadefabs[1000];
    for(int i=0;i<1000;i++){
        datahp[i] = 0;
        datapeak[i] = 0;
        datade[i] = 0;
        datadefabs[i] = 0;
    }
    int dataid=0;

    int qrslen = 1;
    int meanlen = 10;
    int sumlen = 0;
    int qrsmean[10];//存储峰值的数组
    int qrsmeannum[10];//存储峰值位置
    for(int i=0;i<10;i++){
        qrsmean[i] = 0;
        qrsmeannum[i] = 0;
    }
    int meanid=0;//存储峰值数组的id位置
    int sumpeak = 0;//多个峰值和
    int meanpeak = 0;//峰值均值
    annot.time = 0;
    int countann = 0;
    int prenoraml = 0;
    int data[41];//qrs 41points around qrs
    int alasttype = 1;
    int alastrr = 100;
    int nnoraml = 0;
    // Read data from MIT/BIH file until tre is none left.
    while( posd < lengthd)  //local
    {
        if(SampleCount%2==0) {
            dataIN = MAKEWORD(lpc[posd * 3 ], (lpc[posd * 3 + 1 ] & 0x0f));
        }
        else {
            dataIN = MAKEWORD(lpc[posd * 3 + 2], (lpc[posd * 3 + 1] & 0xf0) >> 4);
            posd++;
        }

        if (dataIN & 0x800)
            dataIN |= ~(0xfff); //negative  data, make all the high bit(12 and after) 1
        else dataIN &= 0xfff;        //positive data, make all the hight bit 0
        ++SampleCount ;
        // Pass sample to beat detection and classification.
        delay = bdac.BeatDetectAndClassify(dataIN, &beatType, &beatMatch) ;    //bdac.c
        delay = 45;//36+22;
        //useinqrs
        datahp[dataid] = bdac.qrsdet1.dataqrs[2];
        datapeak[dataid] = bdac.qrsdet1.dataqrs[6];
        datade[dataid] = bdac.qrsdet1.dataqrs[3];
        datadefabs[dataid] = bdac.qrsdet1.dataqrs[4];
        //peak
        if(datapeak[dataid]>0 ){
            if(qrslen<10 && SampleCount > delay)
            {
                sumpeak+=datapeak[dataid];//累积前九个峰值的和
                qrsmean[meanid] = datapeak[dataid];
                qrsmeannum[meanid++] = SampleCount;
            }
            else if (qrslen==10){
                meanpeak = int((sumpeak+datapeak[dataid])*1.0/qrslen+0.5);//计算前十个峰值的均值
                qrsmean[meanid] = datapeak[dataid];
                qrsmeannum[meanid++] = SampleCount;
                if(meanpeak<30)
                    meanpeak = 30;
                sumpeak = 0;
                meanid=0;
                for(int i=0;i<10;i++){
                    if(qrsmean[i]>0.5*meanpeak && qrsmean[i]<2*meanpeak){
                        qrsmean[meanid++]=qrsmean[i]; //把该峰值存入计算峰值均值数组
                        sumpeak += qrsmean[i];        //计算数组内峰值和
                        sumlen++;                     //数组长度
                        beatType = 1;
                        DetectionTime = qrsmeannum[i] - delay ;
                        DetectionTime *= InputFileSampleFrequency ;
                        DetectionTime /= SAMPLE_RATE ;
                        if(annot.time>=DetectionTime){
                            continue;
                        }
                        annot.time = DetectionTime ;
                        annot.anntyp = beatType ;
                        annot.aux = NULL ;
                        annot.width = 10;
                        annot.height = 100;
                        annot.rr = 80;
                        putann2(fileann,&annot,lasttime,0);
                        //WRITE TO THE TMP
                        WRITE_THE_TMP2(annot.anntyp, bdac, m_clusters, m_type, Q_type, S_type,DetectionTime, modeltypen, modeltypev,&delnum);
                    }
                }
                meanpeak = (int)(sumpeak*1.0/sumlen+0.5);
            }
            else{
                countann++;
                if(annotpre.anntyp == 2 )
                {
                    if((SampleCount - delay - annotpre.time)<51)
                        annotpre.anntyp = 15;
                    else if( annotpre.height>0.5*prenoraml && annotpre.height>0.8*annotppre.height)
                        annotpre.anntyp = 1;
                    else
                        annotpre.anntyp = 15;
                }
                if(datapeak[dataid]>0.5*meanpeak && datapeak[dataid]<100){//2*meanpeak){
                    if(meanid>=10){
                        meanid=0;
                    }
                    if(sumlen<10){
                        qrsmean[meanid++]=datapeak[dataid]; //
                        sumpeak += datapeak[dataid];
                        sumlen++;
                        meanpeak = int(sumpeak*1.0/sumlen+0.5);
                    }
                    else if(datapeak[dataid]>0.75*meanpeak && datapeak[dataid]<1.25*meanpeak)
                    {
                        sumpeak += datapeak[dataid] - qrsmean[meanid];
                        meanpeak = int(sumpeak*1.0/meanlen+0.5);
                        qrsmean[meanid++]=datapeak[dataid];
                    }
                    beatType = 1;
                    if(meanpeak>50)
                        meanpeak = 50;
                    else if(meanpeak<10)
                        meanpeak =10;
                }
                else if(datapeak[dataid]>=100){//2*meanpeak){
                    if(datapeak[dataid]>1.5*prenoraml)
                        beatType = 13;
                    else{
                        beatType =1;
                    }
                }
                else{
                    if(countann>2) {
                        if  (SampleCount - delay - annotpre.time < 51)
                            beatType = 15;
                        else{
                            beatType = 2;
                        }
                    }
                    else
                        beatType = 1;
                }
                DetectionTime = SampleCount - delay ;
                DetectionTime *= InputFileSampleFrequency ;
                DetectionTime /= SAMPLE_RATE ;
                if(annot.time>=DetectionTime){
                    continue;
                }
                //annot.time = DetectionTime ;
                annot.anntyp = beatType;
                //annot.height = datapeak[dataid];
                annot.aux = NULL ;

                int noid=dataid-delay-12;
                if (noid<0)
                    noid +=1000;
                double sumround = 0;
                double sumqrs = 0;
                int mk=0;
                //int data[41];
                for(mk;mk<41;mk++){
                    if(mk<10||mk>30){
                        sumround += datahp[noid]*datahp[noid];
                    }
                    else{
                        sumqrs+=datahp[noid]*datahp[noid];
                    }
                    data[mk] = datahp[noid];
                    noid++;
                    if(noid>=1000)
                        noid=0;
                }
                if(annot.anntyp == 1){ //根据qrs和周边的能量比，判断qrs是否是噪声

                    sumround = sqrt(sumround*1.0/20.0);
                    sumqrs = sqrt(sumqrs*1.0/21.0)*0.5;

                    if(sumround>sumqrs){
                        annot.anntyp = 13;
                    }
                }
                int maxdn=0,mindn = 1000,maxid = 10,minid =10; //计算中心点左右最大最小值及其位置
                for(int i=20;i>10;i--)
                {
                    if(data[i]>maxdn){
                        maxdn=data[i];
                        maxid = i;
                    }
                    if(data[i]<mindn){
                        mindn = data[i];
                        minid = i;
                    }
                }
                int maxdnr=0,mindnr = 1000,maxidr = 21,minidr =21;
                for(int i=21;i<31;i++)
                {
                    if(data[i]>maxdnr){
                        maxdnr=data[i];
                        maxidr = i;
                    }
                    if(data[i]<mindnr){
                        mindnr = data[i];
                        minidr = i;
                    }
                }
                //int sum = 0;
                mindn = min(mindn,mindnr);
                maxdn = max(maxdn,maxdnr);

                annot.width = minidr-minid;
                annot.height = maxdn-mindn;//
                if(annot.height>1000)
                    annot.anntyp = 13;
                if(annot.time!=0)
                    annot.rr = DetectionTime - annot.time;
                annot.time = DetectionTime;
                //printf("wid:%d, height:%d,rr:%d\n",annot.width,annot.height,annot.rr);
                if(countann>1){
                    if(annotpre.anntyp == 15 ){
                        annot.rr += annotpre.rr;
                        memcpy(&annotpre,&annot,sizeof(annot));
                    }
                    else {
                        if(annotpre.anntyp == 1 ) {
                            if (annotpre.width > annotppre.width && annotppre.anntyp == 1 ) {
                                if(annotpre.width>(annotppre.width+1)){
                                    if(annotpre.height>annotppre.height*1.15)
                                        annotpre.anntyp = 5;
                                }
                                else if(annotpre.height>annotppre.height*1.15 && annotpre.height>annot.height*1.1 && annotpre.width > (annot.width+1) ){
                                    annotpre.anntyp = 5;
                                }
//                               if(annotpre.anntyp == 5){
//                                   FILE* filepvc = fopen("pvc.txt","a+");
//                                   fprintf(filepvc,"detection:%d,height:%d,%d,%d,wid:%d,%d,%d,rr:%d,%d,%d\n",annotpre.time,annotppre.height,annotpre.height,annot.height,annotppre.width,annotpre.width,annot.width,annotppre.rr,annotpre.rr,annot.rr);
//                                   fclose(filepvc);
//                               }
                            }
                            else if (annotpre.rr < 0.80 * annotppre.rr && alasttype == 1 && alastrr<annotppre.rr*1.05 && alastrr>annotppre.rr*0.95 & annotpre.height<annotppre.height*1.1 && annotpre.height>annotppre.height*0.9)//&& (annotpre.width < (annotppre.width+1)) && (annotpre.width > (annotppre.width-1)) && annotppre.anntyp==1) {
                            {
                                if(annotpre.rr <= 0.9* annot.rr )//&& (annotppre.rr - annotpre.rr)>0.1*128&& annotpre.rr >0.90 * annot.rr
                                    annotpre.anntyp = 9;
                                else if (annotpre.rr > 0.9 * annot.rr && annotpre.rr < 1.1 * annot.rr) {
                                    annotpre.anntyp = 9;
                                }
//                               if(annotpre.anntyp == 9)
//                                   printf("detection:%d,height:%d,%d,%d,wid:%d,%d,%d,rr:%d,%d,%d\n",annotpre.time,annotppre.height,annotpre.height,annot.height,annotppre.width,annotpre.width,annot.width,annotppre.rr,annotpre.rr,annot.rr);


                            }
                            else if(annotppre.anntyp==5){
                                if(annotppre.rr>0.9*annotpre.rr && annotppre.rr<1.1*annotpre.rr  && annotpre.height<annotppre.height*1.05 && annotpre.height>annotppre.height*0.95)
                                {
                                    if((annotpre.width < (annotppre.width+1)) && (annotpre.width>(annotppre.width-1)))
                                        annotpre.anntyp = 5;
                                }

                            }
                            else if(annotppre.anntyp==9){
                                if(annotppre.rr>0.95*annotpre.rr && annotppre.rr<1.05*annotpre.rr && annotpre.height<annotppre.height*1.1 && annotpre.height>annotppre.height*0.9)
                                {
                                    if(alasttype == 1 && annotpre.rr < 0.80 * alastrr)
                                        annotpre.anntyp = 9;
                                    else if(alasttype==9){
                                        annotpre.anntyp = 9;
                                    }
//                                   if(annotpre.anntyp == 9)
//                                   printf("detection:%d,height:%d,%d,%d,wid:%d,%d,%d,rr:%d,%d,%d\n",annotpre.time,annotppre.height,annotpre.height,annot.height,annotppre.width,annotpre.width,annot.width,annotppre.rr,annotpre.rr,annot.rr);

                                }

                            }

                        }
                        if(annotpre.anntyp==1 && annotppre.anntyp == 1 && annotpre.height<annotppre.height*0.2){ //排除分类为normal的小噪声
                            annot.rr += annotpre.rr;
                            memcpy(&annotpre,&annot,sizeof(annot));
                        }
                        else{
                            putann2(fileann, &annotpre, lasttime, 0);
                            //WRITE TO THE TMP
                            WRITE_THE_TMP3(annotpre.anntyp, m_type, Q_type, S_type, V_type, annotpre.time);
                            alasttype = annotppre.anntyp;
                            alastrr = annotppre.rr;
                            memcpy(&annotppre, &annotpre, sizeof(annotpre));
                            memcpy(&annotpre, &annot, sizeof(annot));
                            if (annotppre.anntyp == 1)
                                prenoraml = annotppre.height;
                        }
                    }
                }
                else //(countann==1){
                    memcpy(&annotpre,&annot,sizeof(annot));

            }
            qrslen++;
        }


        //useinqrs
        dataid++;
        if(dataid>=1000)
            dataid=0;
        // printf("%d\n",SampleCount);
        // save the real-data
        OUTlpc[lpcount] =bdac.qrsdet1.datafilt;
        INlpc[lpcount++] = dataIN;
    }

//
    //2 int change to 3 chars
    int dif = LPBUFFER_LGTH/2-1+(HPBUFFER_LGTH-1)/2;
    for(int i=0;i<lengthd*2;i++)
    {
        int id = i+dif;
        if(id>=lengthd*2){
            id=lengthd*2-1;
        }
        lpc2[0] = LOBYTE((short) INlpc[i]);
        lpc2[1] = 0;
        lpc2[1] = HIBYTE((short) INlpc[i]) & 0x0f;
        lpc2[2] = LOBYTE((short) OUTlpc[id]);
        lpc2[1] |= HIBYTE((short) OUTlpc[id]) << 4;
        lpc2 += 3;
    }
    fwrite( buf, sizeof(char), file2c_lsize, fp);
    fclose(fp);//close the 2-channal-dat file
    delete[]buf;
    delete[]lpc;
    delete[]INlpc;
    delete[]OUTlpc;

    wfdb_p16(0, fileann);//STOP WRITE THE ATEST FILE
    fclose(fileann);//CLOSE WRITE THE annotion FILE
    fclose(filed); //CLOSE THE 1-channal-DAT FILE

    // Write the new address book back to disk.
    int Nnum = 0, Vnum=0, Anum = 0;
    int countN = 0,countV = 0,countA=0,countS=0;
    bool Nfind1 = false, Vfind1 = false, Afind1 = false;
    int Nfind1ID = 0, Vfind1ID = 0, Afind1ID = 0;
    fstream tempfile(ecg_tmp_file_path, ios::out | ios::trunc | ios::binary);
    Template1 *tmp1N = tmpN->add_template1s();
    tmp1N->set_id(0);
    Template1 *tmp1V = tmpV->add_template1s();
    tmp1V->set_id(0);
    Template1 *tmp1A = tmpA->add_template1s();
    tmp1A->set_id(0);
    Template1 *tmp1S = tmpS->add_template1s();
    tmp1S->set_id(0);

    if (Q_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1A->add_template2s();
        tmp1->set_id(0);
        countA += Q_type.size();
        for (int k = 0; k < Q_type.size(); k++) {
            tmp1->add_positions_of_beats(Q_type[k]);
        }
    }
    if (V_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1V->add_template2s();
        tmp1->set_id(0);
        countV += V_type.size();
        for (int k = 0; k < V_type.size(); k++) {
            tmp1->add_positions_of_beats(V_type[k]);
        }
    }
    if (S_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1S->add_template2s();
        tmp1->set_id(0);
        countS += S_type.size();
        for (int k = 0; k < S_type.size(); k++) {
            tmp1->add_positions_of_beats(S_type[k]);
        }
    }
    if (m_type.size()>0) {
        Template2 *tmp1;
        tmp1 = tmp1N->add_template2s();
        tmp1->set_id(0);
        countN += m_type.size();
        for (int k = 0; k < m_type.size(); k++) {
            tmp1->add_positions_of_beats(m_type[k]);
        }
    }

    //printf("all tmp = %d\n", Anum + Vnum +Nnum);
    printf("normal = %d\n",m_type.size());
    printf("PVC = %d\n",V_type.size());
    printf("Q = %d\n",Q_type.size());
    printf("S = %d\n",S_type.size());
    if (!tmp.SerializeToOstream(&tempfile)) {
        cerr << "Failed to write address book." << endl;
        return -1;
    }
    google::protobuf::ShutdownProtobufLibrary();
//
    return 0;
}*/
